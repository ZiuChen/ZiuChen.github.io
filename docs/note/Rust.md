# Rust

## Rust ç¯å¢ƒæ­å»º

`rustup` æ˜¯ä¸€ä¸ªç”¨äºç®¡ç† Rust ç‰ˆæœ¬å’Œç›¸å…³å·¥å…·çš„å‘½ä»¤è¡Œå·¥å…·ã€‚

Unix ç³»ç»Ÿ:

```sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

Windows ç³»ç»Ÿ:

ä¸‹è½½å¹¶å®‰è£… [rustup-init.exe](https://static.rust-lang.org/rustup/dist/i686-pc-windows-gnu/rustup-init.exe).

å®‰è£…å®Œæ¯•åï¼Œåœ¨å‘½ä»¤è¡Œæ‰§è¡Œï¼š

```sh
rustc --version
```

å¯ä»¥çœ‹åˆ°è¾“å‡ºçš„ç‰ˆæœ¬å·ä¿¡æ¯ï¼Œåˆ™ rust å·²å®‰è£…å®Œæ¯•ã€‚

## Hello, Rust!

```sh
mkdir hello_rust
```

åˆ›å»ºå¹¶ç¼–è¾‘ç¬¬ä¸€ä¸ª Rust ç¨‹åºï¼š

```rs
// main.rs
fn main() {
    println!("Hello, Rust!");
}
```

æ‰§è¡Œ `rustc ./hello_rust/main.rs`

å¯ä»¥çœ‹åˆ°åœ¨ä»£ç åŒç›®å½•ä¸‹è¾“å‡ºäº†äºŒè¿›åˆ¶æ–‡ä»¶ `main`ï¼Œåœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œï¼š

```sh
./main
```

å¯ä»¥çœ‹åˆ°è¾“å‡ºï¼š

```sh
> Hello, Rust!
```

ä¸‹é¢æˆ‘ä»¬åˆ†æä¸€ä¸‹è¿™ä¸ªç¨‹åºï¼š

åœ¨ Rust ä¸­ï¼Œå‡½æ•°åä¸º `main` çš„å‡½æ•°æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ï¼Œå®ƒæ€»æ˜¯ä¼šè¢«æœ€å…ˆæ‰§è¡Œï¼š

```rs
fn main() {

}
```

åœ¨å‡½æ•°ä½“ä¸­çš„ä»£ç ï¼š

```rs
    println!("Hello, Rust!")
```

`println!` æ˜¯ä¸€ä¸ª Rust å®ï¼ˆmacroï¼‰ï¼Œå®ƒä¸å‡½æ•°è°ƒç”¨çš„åŒºåˆ«æ˜¯å®ƒä»¥ `!` ç»“å°¾ã€‚

`"Hello, Rust!"` æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¼ é€’ç»™äº† `println!` å®ã€‚

**Rust ç¨‹åºçš„ç¼–è¯‘å’Œè¿è¡Œæ˜¯ç‹¬ç«‹è¿›è¡Œçš„ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥å°†ç¼–è¯‘äº§ç‰©ç›´æ¥å‘é€ç»™åˆ«äººï¼Œåˆ«äººä¸éœ€è¦å®‰è£… Rust ä¹Ÿå¯ä»¥è¿è¡Œ**

è¿™ä¸ Ruby Python JavaScript è¿™ç±»åŠ¨æ€è¯­è¨€ä¸åŒï¼ŒRust æ˜¯ä¸€é—¨**é¢„ç¼–è¯‘é™æ€è¯­è¨€**ï¼ˆahead-of-time compiledï¼‰

ç®€å•é¡¹ç›®å¯ä»¥ä½¿ç”¨ rustcï¼Œä½†éšç€é¡¹ç›®å¤æ‚åº¦å¢é•¿ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ cargo æ¥ç®¡ç†é¡¹ç›®ä¸­çš„ä¸‰æ–¹ä¾èµ–ã€ç®¡ç†çœŸå®ä¸–ç•Œä¸­ Rust ç¨‹åºå¼€å‘çš„æ–¹æ–¹é¢é¢ã€‚

## Cargo

```sh
# åˆå§‹åŒ–ä¸€ä¸ª Cargo é¡¹ç›®
cargo new hello_cargo
```

æ‰§è¡Œ `cargo new` åä¼šè‡ªåŠ¨å¸®ä½ åˆå§‹åŒ–ä¸€ä¸ª Git ä»“åº“ï¼Œå¦‚æœä½ æ˜¯åœ¨ä¸€ä¸ªç°å­˜çš„ Git ä»“åº“ä¸­æ‰§è¡Œçš„åˆå§‹åŒ–ï¼Œé‚£ä¹ˆå°±ä¸ä¼šæ‰§è¡Œæ­¤æ“ä½œã€‚

é™¤äº†å¸®ä½ åˆ›å»ºäº†ä¸€ä¸ª HelloWorld ä»£ç ï¼Œ`cargo` è¿˜åˆ›å»ºäº†ä¸€ä¸ª `cargo.toml` æ–‡ä»¶ï¼š

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

`[package]`ã€`[dependencies]` åˆ†åˆ«ä»£è¡¨æ˜¯ä¸€ä¸ªç‰‡æ®µï¼š

- å…¶ä¸­ `[package]` ä¸‹çš„å­—æ®µ `name`ã€`version` å’Œ `edition` è¡¨ç¤ºé¡¹ç›®çš„åç§°ã€é¡¹ç›®çš„ç‰ˆæœ¬å’Œä½¿ç”¨çš„ Rust ç‰ˆæœ¬ã€‚
- `[dependenciese]` ä¸­è®°å½•ç€é¡¹ç›®çš„ç¬¬ä¸‰æ–¹ä¾èµ–ï¼Œè¿™äº›ä¾èµ–è¢«ç§°ä¸º *crates*

Cargo æœŸæœ›æ‰€æœ‰çš„æºä»£ç éƒ½å­˜æ”¾åœ¨ `src/` ç›®å½•ä¸‹ï¼Œé¡¹ç›®æ ¹ç›®å½•ä¸­ä¿å­˜å¦‚ READMEã€LICENSE è¿™ç±»çš„æ–‡ä»¶ã€‚

### åœ¨ Cargo ä¸­æ„å»ºå’Œè¿è¡Œé¡¹ç›®

æ‰§è¡Œ `cargo build` å¯ä»¥æ„å»ºé¡¹ç›®ï¼š

```sh
cargo build
```

æ„å»ºäº§ç‰©å°†è¾“å‡ºåœ¨ `target/debug/` ç›®å½•ä¸‹ï¼Œè¿™æ˜¯å› ä¸º `cargo build` æ˜¯è°ƒè¯•æ„å»ºï¼ˆdebug buildï¼‰

æ‰§è¡Œï¼š

```sh
cargo run
```

å³å¯è¿è¡Œåˆšåˆš build è¾“å‡ºçš„äº§ç‰©ã€‚å¦‚æœä½ åœ¨ `cargo run` ä¹‹å‰æœªæ„å»ºæˆ–ä¿®æ”¹äº†ä»£ç ï¼Œ`cargo` ä¼šè‡ªåŠ¨å¸®ä½ å®Œæˆ re-build å¹¶æ‰§è¡Œä»£ç ã€‚

```sh
cargo check
```

è¿™ä¸ªå‘½ä»¤å¯ä»¥å¸®ä½ å®Œæˆä»£ç çš„é™æ€æ£€æŸ¥ä¸”ä¸è¾“å‡ºä»»ä½•æ–‡ä»¶ï¼Œç”±äºå®ƒä¸éœ€è¦å‡†å¤‡è¾“å‡ºæ„å»ºäº§ç‰©ï¼Œæ‰€ä»¥å®ƒæ¯” `cargo build` è¦å¿«å¾—å¤šã€‚

### å‘å¸ƒæ„å»º

ä¸è°ƒè¯•æ„å»ºä¸åŒï¼Œå¯ä»¥æ‰§è¡Œï¼š

```sh
cargo build --release
```

æ¥æ„å»ºä¸€ä¸ªç”¨äºç”Ÿäº§ç¯å¢ƒçš„äº§ç‰©ï¼Œè¿™ä¼šåœ¨ `target/release/` ä¸‹è¾“å‡ºäº§ç‰©è€Œä¸æ˜¯ `target/debug/` ä¸‹ã€‚

å‘å¸ƒæ„å»ºçš„äº§ç‰©å¾€å¾€æœ‰é’ˆå¯¹ç”Ÿäº§çš„æ›´å¤šä¼˜åŒ–ï¼ŒåŒæ—¶æ„å»ºéœ€è¦èŠ±è´¹çš„æ—¶é—´ä¹Ÿæ›´é•¿ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦æœ‰è°ƒè¯•æ„å»ºä¸å‘å¸ƒæ„å»ºçš„åŒºåˆ†ï¼šè°ƒè¯•æ„å»ºç”¨äºå¼€å‘æ—¶æ›´å¿«çš„çœ‹åˆ°æœ€ç»ˆæ•ˆæœï¼Œéœ€è¦ç»å¸¸å¿«é€Ÿåœ°æ‰§è¡Œæ„å»ºï¼Œè€Œå‘å¸ƒæ„å»ºåˆ™æ˜¯ä¸ºäº†æœ€ç»ˆç”¨æˆ·ä½¿ç”¨æ—¶æ„å»ºçš„ã€‚

## Gussing Game

å†™ä¸€ä¸ªçŒœæ•°æ¸¸æˆï¼š

ä½¿ç”¨ `use` æ ‡è¯†ç¬¦æ¥ä»æ ‡å‡†åº“ä¸­å¼•å…¥ `io` åº“ï¼Œä¹‹åå°±å¯ä»¥åœ¨å½“å‰ä½œç”¨åŸŸä¸­é€šè¿‡ `io:stdin()` è¯»å–åˆ°ç”¨æˆ·è¾“å…¥ï¼š

```rs
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

æ‰§è¡Œ `cargo run` åæµ‹è¯•ä¸€ä¸‹ï¼š

```sh
Guess the number!
Please input your guess.
6
You guessed: 6
```

### ä½¿ç”¨å˜é‡ä¿å­˜æ•°æ®

åœ¨ Rust ä¸­ï¼Œä½¿ç”¨ `let` ä¸ `const` å£°æ˜çš„å˜é‡é»˜è®¤éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œé€šè¿‡ç»™ `let` å£°æ˜çš„å˜é‡åŠ ä¸Š `mut` æ ‡è®°ï¼Œæ¥è®© guess è¿™ä¸ªå˜é‡å¯å˜ï¼ˆmutatiableï¼‰

`::new` ä¸­çš„ `::` è¡¨æ˜ï¼š`new` æ˜¯ `String` ç±»å‹çš„ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œåœ¨ä¸€äº›è¯­è¨€ä¸­å®ƒè¢«ç§°ä¹‹ä¸ºé™æ€æ–¹æ³•ï¼ˆstatic functionï¼‰

æ€»çš„æ¥è¯´ï¼Œ`let mut guess = String::new();` è¿™ä¸€è¡Œåˆ›å»ºäº†ä¸€ä¸ªå¯å˜å˜é‡ï¼Œå½“å‰å®ƒç»‘å®šåˆ°ä¸€ä¸ªæ–°çš„ `String` ç©ºå®ä¾‹ä¸Šã€‚

### è¯»å–ç”¨æˆ·è¾“å…¥

å¦‚æœåœ¨ç¨‹åºå¼€å¤´æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ `use` æ¥å¼•å…¥ `io` åº“ï¼Œåœ¨ä»£ç ä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š

```rs
std::io::stdin()
```

æ¥åŠ¨æ€åœ°å¼•å…¥ `io` åº“ï¼Œé€šè¿‡ `read_line` æ¥ä»æ ‡å‡†è¾“å…¥å¥æŸ„è·å–ç”¨æˆ·è¾“å…¥ã€‚

å°† `&mut guess` ä¼ é€’ç»™ `read_line`ï¼Œå…¶ä¸­ `&` è¡¨æ˜ä¼ é€’çš„æ˜¯ä¸€ä¸ªå˜é‡çš„å¼•ç”¨ï¼ŒåŒæ—¶ç”±äºå˜é‡æ˜¯ä¸å¯å˜çš„ï¼Œ`&mut` è¡¨ç¤ºè¿™ä¸ªå¼•ç”¨å¯ä»¥ä¿®æ”¹ã€‚

### ä½¿ç”¨ Result ç±»å‹å¤„ç†æ½œåœ¨é”™è¯¯

å‰æ–‡ä¸­æˆ‘ä»¬è¯´ `read_line` ä¼šæŒç»­åœ°å°†ç”¨æˆ·è¾“å…¥é™„åŠ åˆ°ä¼ é€’ç»™å®ƒçš„å­—ç¬¦ä¸²ä¸­ï¼Œå®ƒä¹Ÿä¼šè¿”å›ä¸€ä¸ª `Result` ç±»å‹çš„å€¼ã€‚

`Result` ç±»å‹æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼ŒåŒ…å«ä¸¤ç§æˆå‘˜ç±»å‹ï¼š

- `Ok`: è¡¨ç¤ºæ“ä½œæˆåŠŸï¼Œå†…éƒ¨åŒ…å«æˆåŠŸæ—¶äº§ç”Ÿçš„å€¼ï¼›
- `Err`: è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼ŒåŒ…å«å¤±è´¥çš„å‰å› åæœã€‚

è¿™äº› `Result` ç±»å‹çš„ä½œç”¨æ˜¯å¤„ç†é”™è¯¯ä¿¡æ¯ï¼Œ`Result` çš„å®ä¾‹å…·æœ‰ `expect` æ–¹æ³•ï¼Œå¦‚æœ `io:Result` å®ä¾‹çš„å€¼æ˜¯ `Err`ï¼Œ`expect` ä¼šå¯¼è‡´ç¨‹åºå´©æºƒï¼Œå¹¶æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ã€‚

å¦‚æœ `read_line` è¿”å› `Err`ï¼Œåˆ™å¯èƒ½æ˜¯æ¥æºäºåº•å±‚æ“ä½œç³»ç»Ÿé”™è¯¯çš„ç»“æœã€‚å¦‚æœ `Result` å®ä¾‹çš„å€¼æ˜¯ `Ok`ï¼Œ`expect` ä¼šè·å– `Ok` ä¸­çš„å€¼å¹¶åŸæ ·è¿”å›ã€‚

åœ¨æ­¤ä¾‹å­ä¸­ï¼Œè¿™ä¸ªå€¼æ˜¯ç”¨æˆ·è¾“å…¥åˆ°æ ‡å‡†è¾“å…¥ä¸­çš„å­—èŠ‚æ•°ã€‚

### ä½¿ç”¨ println! å ä½ç¬¦æ‰“å°å€¼

ä¸‹é¢è¿™ä¸¤ç§ `println!` æ˜¯ç­‰ä»·çš„ï¼Œä»–ä»¬éƒ½å¯ä»¥å°†å˜é‡æ‰“å°åˆ°æŒ‡å®šä½ç½®ï¼š

```rs
println!("You guessed: {guess}");
println!("You guessed: {}", guess);
```

### ç”Ÿæˆä¸€ä¸ªéšæœºæ•°

åœ¨ Rust æ ‡å‡†åº“ä¸­ä¸åŒ…å«éšæœºæ•°åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ rand crateï¼š

```sh
cargo add rand
```

å®‰è£…åï¼Œæˆ‘ä»¬åˆ° Cargo.toml ä¸­å¯ä»¥çœ‹åˆ°ï¼š

```toml
[dependencies]
rand = "0.8.5"
```

è¿™é‡Œçš„ `"0.8.5"` å®é™…ä¸Šæ˜¯ `"^0.8.5"` çš„ç®€å†™ï¼Œå®ƒè¡¨ç¤ºè‡³å°‘æ˜¯ `0.8.5` ä½†å°äº `0.9.0` çš„ç‰ˆæœ¬ã€‚

å…·ä½“å¯ä»¥å‚çœ‹[è¯­ä¹‰åŒ–ç‰ˆæœ¬ï¼ˆSemantic Versioningï¼‰](https://semver.org/)

Cargo é€šè¿‡ Cargo.lock æ–‡ä»¶æ¥ä¿è¯æ¯ä¸€æ¬¡æ„å»ºéƒ½æ˜¯å¯ä»¥è¢«é‡ç°çš„ï¼Œä»»ä½•äººåœ¨ä»»ä½•æ—¶å€™é‡æ–°æ„å»ºä»£ç éƒ½ä¼šäº§ç”Ÿç›¸åŒçš„ç»“æœï¼ŒCargo åªä¼šä½¿ç”¨ä½ æŒ‡å®šçš„ä¾èµ–ç‰ˆæœ¬ã€‚

> å¦‚æœ rand åº“ä¸‹å‘¨å‘å¸ƒäº† `0.8.6` ç‰ˆæœ¬ï¼Œæ–°ç‰ˆæœ¬ä¸­ä¿®å¤äº†ä¸€ä¸ª BUG ä½†å­˜åœ¨ç ´åæ€§å˜æ›´ï¼Œå¦‚æœä½ æ²¡æœ‰æ˜¾å¼åœ°åœ¨ Cargo.toml ä¸­å‡çº§ rand åº“ï¼Œé‚£ Cargo ä¼šæŒ‰ç…§ä¸Šä¸€æ¬¡æ„å»ºæˆåŠŸæ—¶ç”Ÿæˆçš„ Cargo.lock è®°å½•çš„ç¬¬ä¸‰æ–¹åº“ç‰ˆæœ¬æ¥æ„å»ºã€‚

å¦‚æœä½ ç¡®å®è¦å‡çº§ crateï¼Œå¯ä»¥ä½¿ç”¨ï¼š

```sh
cargo update
```

æ¥å¿½ç•¥ Cargo.lock æ–‡ä»¶ï¼Œå¹¶è®¡ç®—æ‰€æœ‰ç¬¦åˆ Cargo.toml å£°æ˜çš„æœ€æ–°ç‰ˆæœ¬ã€‚

å®‰è£…å®Œäº† rand crateï¼Œæˆ‘ä»¬ä¸‹é¢æ¥ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼š

```rs
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

`use rand:Rng;` å…¶ä¸­ï¼Œ`Rng` æ˜¯ä¸€ä¸ª traitï¼Œå®ƒå®šä¹‰äº†éšæœºæ•°ç”Ÿæˆå™¨å®ç°çš„æ–¹æ³•çš„è¯ï¼Œæ­¤ trait å¿…é¡»åœ¨ä½œç”¨åŸŸä¸­ã€‚

æˆ‘ä»¬è°ƒç”¨ `rand::thread_rng` å‡½æ•°æä¾›å®é™…ä½¿ç”¨çš„**éšæœºæ•°ç”Ÿæˆå™¨**ï¼šå®ƒä½äºå½“å‰æ‰§è¡Œçº¿ç¨‹çš„æœ¬åœ°ç¯å¢ƒä¸­ï¼Œä»æ“ä½œç³»ç»Ÿè·å– seedã€‚

éšåè°ƒç”¨éšæœºæ•°ç”Ÿæˆå™¨çš„ `gen_range` æ–¹æ³•ï¼Œå®ƒç”± `Rng` trait å®šä¹‰ï¼Œè·å–ä¸€ä¸ªèŒƒå›´è¡¨è¾¾å¼ï¼ˆRange expressionï¼‰ä½œä¸ºå‚æ•°ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªåœ¨æ­¤èŒƒå›´ä¹‹é—´çš„éšæœºæ•°ã€‚

èŒƒå›´è¡¨è¾¾å¼ä½¿ç”¨ `start..=end` è¿™æ ·çš„å½¢å¼ï¼Œå¦‚ `1..=100` å°±ä»£è¡¨ 1 åˆ° 100 ä¹‹é—´ã€‚

::: info
ä½ ä¸å¯èƒ½å‡­ç©ºçŸ¥é“åº”å½“ use å“ªä¸ª traitï¼Œä»¥åŠåº”å½“ä» crate ä¸­è°ƒç”¨å“ªä¸ªæ–¹æ³•ï¼Œå› æ­¤æ¯ä¸ª crate éƒ½æœ‰è¯´æ˜æ–‡æ¡£ã€‚
é€šè¿‡è°ƒç”¨ `cargo doc --open` æ¥æ„å»ºæ‰€æœ‰æœ¬åœ°ä¾èµ–æä¾›çš„æ–‡æ¡£å¹¶åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ã€‚
:::

### å¯¹æ¯”ä¸¤ä¸ªæ•°å­—

```rs
// æ­¤ä»£ç ä¸å¯è¿è¡Œ
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```

æˆ‘ä»¬å¼•å…¥ `std::cmp::Ordering` åˆ°ä½œç”¨åŸŸä¸­ã€‚`Ordering` ä¹Ÿæ˜¯ä¸€ä¸ªæšä¸¾ï¼Œå…¶æˆå‘˜åŒ…å« `Less`ã€`Greater` å’Œ `Equal`ï¼Œè¿™æ˜¯åœ¨ä¸¤ä¸ªå€¼è¿›è¡Œæ¯”è¾ƒæ—¶å¯èƒ½å‡ºç°çš„ä¸‰ç§ç»“æœã€‚

`cmp` æ–¹æ³•ç”¨äºæ¯”è¾ƒä¸¤ä¸ªå€¼ï¼Œå¹¶ä¸”**å¯ä»¥åœ¨ä»»ä½•å¯æ¯”è¾ƒçš„å€¼ä¸Šè°ƒç”¨**ã€‚å®ƒè·å–ä¸€ä¸ªè¢«æ¯”è¾ƒå€¼çš„å¼•ç”¨ï¼šå°† `guess` ä¸ `secret_number` ä½œæ¯”è¾ƒã€‚ç„¶åè¿”å›ä¸€ä¸ªé€šè¿‡ `use` å¼•å…¥ä½œç”¨åŸŸçš„ `Ordering` æšä¸¾çš„æˆå‘˜ã€‚

ä½¿ç”¨ `match` è¡¨è¾¾å¼ï¼Œæ ¹æ®å¯¹ `guess` å’Œ `secret_number` è°ƒç”¨ `cmp` è¿”å›çš„ `Ordering` æˆå‘˜ï¼Œæ¥å†³å®šä¸‹ä¸€æ­¥åº”è¯¥è¦åšä»€ä¹ˆã€‚

`match` è¡¨è¾¾å¼ç”±ä¼—å¤šçš„åˆ†æ”¯ï¼ˆarmsï¼‰æ„æˆï¼Œæ¯ä¸ªåˆ†æ”¯éƒ½åŒ…å«ä¸€ä¸ª pattern ä»¥åŠ pattern è¢«åŒ¹é…æ—¶è¦æ‰§è¡Œçš„ä»£ç ã€‚

å°è¯•æ‰§è¡Œæ­¤ä»£ç ï¼Œç¼–è¯‘å™¨ä¼šæŠ›å‡ºé”™è¯¯ï¼šä¸åŒ¹é…çš„ç±»å‹ï¼ˆmismatched typesï¼‰ã€‚Rust æœ‰ä¸€ä¸ªé™æ€å¼ºç±»å‹ç³»ç»Ÿï¼ŒåŒæ—¶ä¹Ÿæœ‰ç±»å‹æ¨æ–­ã€‚

å½“æˆ‘ä»¬å†™å‡º `let guess = String::new();` æ—¶ï¼ŒRust ä¼šå¸®æˆ‘ä»¬æ¨æ–­å‡º `guess` å˜é‡åº”å½“æ˜¯ `String` ç±»å‹ã€‚

è€Œ `secret_number` æ˜¯ 1 - 100 ä¹‹é—´çš„æ•°å­—ç±»å‹ï¼Œè€Œç¬¦åˆè¿™ä¸ªè¦æ±‚ï¼ˆ1~100ä¹‹é—´ï¼‰çš„æ•°å­—ï¼Œåœ¨ Rust ä¸­æœ‰ä¸‹é¢å‡ ç§ï¼š

- `i32` 32ä½æ•°å­—ï¼›
- `u32` 32ä½æ— ç¬¦å·æ•°å­—ï¼›
- `i64` 64ä½æ•°å­—
- ç­‰ç­‰ ...

Rust é»˜è®¤ä½¿ç”¨ `i32`ï¼Œæ‰€ä»¥ Rust é»˜è®¤ä¸º `secret_number` æ¨æ–­å‡ºçš„ç±»å‹æ˜¯ `i32`ï¼Œå¯¼è‡´äº†å­—ç¬¦ä¸²ä¸æ•°å­—ä½œå¯¹æ¯”çš„æƒ…å†µã€‚

è¦å°† `String` è½¬åŒ–ä¸ºæ•°å­—ç±»å‹æ‰èƒ½ä¸ `secret_number` ä½œæ¯”è¾ƒï¼š

```rs
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

ä¸Šé¢çš„ä»£ç å°†é‡æ–°å£°æ˜ `guess` å˜é‡ï¼Œè¿™ä¸ªç‰¹æ€§å«éšè—ï¼ˆShadowingï¼‰ï¼Œé€šè¿‡ `guess.trim()` å»é™¤å­—ç¬¦ä¸²å¤´å°¾çš„ç©ºç™½å­—ç¬¦ï¼ˆå¦‚ç”¨æˆ·è¾“å…¥ 5 å¹¶æŒ‰ä¸‹ç©ºæ ¼åï¼Œåœ¨ Unix ç³»ç»Ÿä¸­ `guess` çš„å€¼ä¸º `5\n`ï¼Œåœ¨ Windows ç³»ç»Ÿä¸­ `guess` çš„å€¼ä¸º `5\r\n`ï¼‰

`guess.parse()` æ–¹æ³•ä¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå…¶ä»–ç±»å‹ï¼Œé€šè¿‡ç»™ `guess` æ˜¾å¼æŒ‡å®šç±»å‹æ¥å‘Šè¯‰ `guess` æ–¹æ³•è½¬åŒ–çš„ç›®æ ‡ç±»å‹ï¼Œè¿™é‡Œçš„ç›®æ ‡ç±»å‹æ˜¯ `u32`ã€‚

åŒæ—¶ï¼Œä¸ºäº†é˜²æ­¢å­—ç¬¦ä¸²ä¸­åŒ…å«ç‰¹æ®Šå­—ç¬¦ç­‰åŸå› å¯¼è‡´ `parse` æ‰§è¡Œå¤±è´¥ï¼Œè¿™é‡Œç”¨ `expect` æ¥å¯¹è½¬åŒ–æ˜¯å¦æˆåŠŸè¿›è¡Œæç¤ºï¼š

- å¦‚æœ `parse` ä¸èƒ½ä»å­—ç¬¦ä¸²ç”Ÿæˆä¸€ä¸ªæ•°å­—ï¼Œè¿”å›ä¸€ä¸ª `Result` çš„ `Err` æˆå‘˜æ—¶ï¼Œ`expect` æ–¹æ³•ä¼šä½¿ç¨‹åºç»“æŸå¹¶æ‰“å°é™„åŠ çš„ä¿¡æ¯ã€‚
- å¦‚æœ `parse` æˆåŠŸæ‰§è¡Œï¼Œé‚£ä¹ˆå®ƒä¼šè¿”å› `Result` çš„ `Ok` æˆå‘˜ï¼Œç„¶å `expect` ä¼šè¿”å› `Ok` å€¼ä¸­çš„æ•°å­—ã€‚

### ä½¿ç”¨å¾ªç¯æ¥å…è®¸å¤šæ¬¡çŒœæµ‹

å¯ä»¥ä½¿ç”¨ `loop` å…³é”®å­—æ¥åˆ›å»ºä¸€ä¸ªæ— é™å¾ªç¯ï¼Œç»™ç”¨æˆ·æ›´å¤šæœºä¼šæ¥çŒœæ•°ã€‚

```rs
    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            },
        }
    }
```

å½“ç”¨æˆ·æˆåŠŸçŒœå¯¹åï¼Œä¼šæ‰§è¡Œ `break;` é€€å‡ºç¨‹åºã€‚

### å¿½ç•¥éæ•°å­—çš„çŒœæµ‹å¹¶ç»§ç»­æ¸¸æˆ

ç›®å‰çš„ä»£ç å¦‚æœç”¨æˆ·è¾“å…¥äº†éæ•°å­—ï¼Œä¼šå¯¼è‡´ `parse` å¤±è´¥ï¼Œè¿›è€Œå¯¼è‡´ç¨‹åºé€€å‡ºï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ”¹å†™è¿™éƒ¨åˆ†çš„é€»è¾‘ï¼Œå°† `expect` è°ƒç”¨ æ”¹ä¸º `match`ï¼š

```rs
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {guess}");

        // --snip--
```

è¿™æ ·å½“é‡åˆ°é”™è¯¯æ—¶ç¨‹åºä¸å†å´©æºƒï¼Œè€Œæ˜¯è¿›å…¥åˆ° `match` çš„é”™è¯¯åˆ†æ”¯ä¸­å¤„ç†é”™è¯¯ï¼šè°ƒç”¨ `continue;` ç»§ç»­å¾ªç¯ã€‚

### æ€»ç»“

è¿™ä¸€ç« é‡Œæˆ‘ä»¬å­¦ä¹ äº†ä½¿ç”¨ `let` å£°æ˜å˜é‡ã€å˜é‡éšè—ã€ç±»å‹è½¬åŒ–ã€`match` å¤„ç†å¤šåˆ†æ”¯ä»»åŠ¡ã€`loop` å¾ªç¯ã€‚

è¿˜å­¦ä¹ äº†å¤–éƒ¨ crate çš„ä½¿ç”¨ã€å¦‚ä½•æŒ‡å®šæ•°æ®ç±»å‹ç­‰

## å¸¸è§ç¼–ç¨‹æ¦‚å¿µ

### å˜é‡å’Œå¯å˜æ€§

å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼ˆImmutableï¼‰ï¼Œè¿™æ˜¯ Rust æä¾›çš„ä¼—å¤šç‰¹æ€§ä¹‹ä¸€ï¼š

ä¸‹é¢çš„ä»£ç ç”±äºä¿®æ”¹äº† `x` å¯¼è‡´ç¼–è¯‘ä¸é€šè¿‡ï¼š

```rs
fn main() {
    let x = 5;
    println!("x is {}", x);
    x = 6;
    println!("x is {}", x);
}
```

ç¼–è¯‘å™¨æŠ›å‡ºçš„é”™è¯¯ä¿¡æ¯ï¼šcannot assign twice to immutable variable `x`

è¦è®© `x` å˜å¾—å¯å˜ï¼Œå¯ä»¥åœ¨å£°æ˜ `let` åæ·»åŠ  `mut`ï¼š

```rs
let mut x = 5;
```

è¿™æ ·å°±å¯ä»¥ä¿®æ”¹ `x` çš„å€¼äº†ã€‚

é™¤äº† `let`ï¼Œè¿˜å¯ä»¥é€šè¿‡ `const` å£°æ˜ä¸€ä¸ªå¸¸é‡ï¼š

- å¸¸é‡æ€»æ˜¯ä¸å¯å˜ï¼Œä¸”ä¸å…è®¸å¯¹å¸¸é‡ä½¿ç”¨ `mut`
- å¿…é¡»åœ¨å£°æ˜æ—¶æ³¨æ˜å€¼çš„ç±»å‹
- å¸¸é‡åªèƒ½è¢«è®¾ç½®ä¸ºå¸¸é‡è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯ä»»ä½•åªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—å‡ºçš„å€¼

```rs
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

è¿™é‡Œçš„ `60 * 60 * 3` ä¼šåœ¨ç¼–è¯‘å™¨ç¼–è¯‘æ—¶æ‰§è¡Œè¿ç®—ï¼Œè¿™ä½¿æˆ‘ä»¬å¯ä»¥é€‰æ‹©æ›´å®¹æ˜“ç†è§£å’ŒéªŒè¯çš„æ–¹å¼æ¥å†™å‡ºè¿™ä¸ªå€¼ï¼Œè€Œä¸æ˜¯ç›´æ¥å°†å¸¸é‡è®¾ç½®ä¸º `10,800`ã€‚

åœ¨å‰æ–‡ä¸­æˆ‘ä»¬ä»‹ç»äº†å˜é‡éšè—ï¼Œåå£°æ˜çš„åŒåå˜é‡å°†ä¼šå±è”½æ‰ä¹‹å‰å£°æ˜çš„å˜é‡ï¼Œç›´åˆ°æ–°çš„å˜é‡ä¹Ÿè¢«éšè—æˆ–ä½œç”¨åŸŸç»“æŸï¼š

```rs
fn main() {
    let x = 5; // 5

    let x = x + 1; // 6

    {
        let x = x * 2;
        println!("x is {}", x); //  12
    }

    println!("x is {}", x); // 6
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œéšè—ä¸å°†å˜é‡æ ‡è®°ä¸º `mut` æ˜¯æœ‰åŒºåˆ«çš„ï¼Œå½“å¯¹å˜é‡è¿›è¡Œé‡æ–°èµ‹å€¼æ—¶ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨ `mut` é‚£ä¹ˆä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯ã€‚é€šè¿‡å˜é‡éšè—ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ–°çš„å˜é‡è¿›è¡Œä¸€äº›è®¡ç®—ï¼Œä½†è®¡ç®—å®Œä¹‹åå˜é‡ä¾ç„¶æ˜¯ä¸å¯å˜çš„ã€‚

`mut` ä¸éšè—çš„å¦ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼šå½“å†æ¬¡ä½¿ç”¨ `let` å£°æ˜å˜é‡æ—¶ï¼Œéšè—å®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹å˜å€¼çš„ç±»å‹ï¼Œåªä¸è¿‡å¤ç”¨è¿™ä¸ªåå­—ï¼š

å¦‚æœæ²¡æœ‰å˜é‡éšè—ï¼Œä»£ç å¯èƒ½ä¼šåƒè¿™æ ·ï¼š

```rs
let spaces_str = "    ";
let spaces_num = spaces_str.len();
```

åˆ©ç”¨å˜é‡éšè—ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å¤ç”¨ç›¸åŒå˜é‡åï¼š

```rs
let spaces = "    "; // æ–‡æœ¬ä¹‹é—´çš„ç©ºæ ¼æ•°é‡
let spaces = spaces.len(); // å¤šå°‘ä¸ªç©ºæ ¼
```

ç„¶è€Œï¼Œå¦‚æœä½¿ç”¨ `mut`ï¼Œä»–ä¸å…è®¸ä¿®æ”¹å˜é‡çš„ç±»å‹ï¼š

```rs
let spaces = "    ";
spaces = spaces.len(); // é”™è¯¯ï¼šä¸èƒ½æ”¹å˜å˜é‡çš„ç±»å‹
```

### æ•°æ®ç±»å‹

åœ¨ Rust ä¸­ï¼Œæ¯ä¸€ä¸ªå€¼éƒ½å±äºæŸä¸€ç§æ•°æ®ç±»å‹ï¼ˆdata typeï¼‰ï¼Œè¿™å‘Šè¯‰ Rust å®ƒè¢«æŒ‡å®šä¸ºä½•ç§æ•°æ®ã€‚

Rust æ˜¯é™æ€ç±»å‹ï¼ˆstatically typedï¼‰è¯­è¨€ç¼–è¯‘æ—¶å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œå½“å¤šç§ç±»å‹å‡æœ‰å¯èƒ½æ—¶ï¼Œä¾‹å¦‚ä½¿ç”¨ `parse` å°† `String` è½¬æ¢ä¸ºæ•°å­—æ—¶ï¼Œå¿…é¡»å¢åŠ ç±»å‹æ³¨è§£ï¼Œåƒè¿™æ ·ï¼š

```rs
let guess: u32 = "42".parse().expect("Not a number!")
```

åœ¨ Rust ä¸­æœ‰ä¸¤ç§æ•°æ®ç±»å‹å­é›†ï¼šæ ‡é‡å’Œå¤åˆ

#### æ ‡é‡ç±»å‹ï¼ˆscalarï¼‰

##### æ•´å‹

æ•´å‹æ˜¯ä¸€ä¸ªæ²¡æœ‰å°æ•°éƒ¨åˆ†çš„æ•°å­—ï¼Œä¾‹å¦‚ `u32` ä»£è¡¨ä¸€ä¸ªå æ® 32 bit çš„æ— ç¬¦å·æ•´æ•°ã€‚å…¶ä¸­**æœ‰ç¬¦å·**å’Œ**æ— ç¬¦å·**ä»£è¡¨æ•°å­—èƒ½å¦ä¸ºè´Ÿå€¼ã€‚

| é•¿åº¦    | æœ‰ç¬¦å· | æ— ç¬¦å· |
|-------|------|------|
| 8-bit  | i8   | u8   |
| 16-bit | i16  | u16  |
| 32-bit | i32  | u32  |
| 64-bit | i64  | u64  |
| 128-bit| i128 | u128 |
| arch   | isize| usize|

æœ‰ç¬¦å·çš„æ•´å‹å¯ä»¥å­˜å‚¨ä» $-(2^{n-1})$ åˆ° $2^{n-1}-1$ åœ¨å†…çš„æ•°å­—ï¼Œè¿™é‡Œçš„ $n$ ä»£è¡¨ä½æ•°ã€‚

ä¾‹å¦‚ `i8` å¯ä»¥å­˜å‚¨ $-(2^7)$ åˆ° $2^7-1$ åœ¨å†…çš„æ•°å­—ï¼Œä¹Ÿå°±æ˜¯ä» -128 åˆ° 127ã€‚

æ— ç¬¦å·çš„æ•´å‹å¯ä»¥å­˜å‚¨ä» $0$ åˆ° $2^n-1$çš„æ•°å­—ã€‚

æ‰€ä»¥ `u8` å¯ä»¥å­˜å‚¨ $0$ åˆ° $2^8-1$ çš„æ•°å­—ï¼Œä¹Ÿå°±æ˜¯ 0 åˆ° 255ã€‚

å¦å¤–ï¼Œ`isize` ä¸ `usize` ç±»å‹ä¾èµ–è¿è¡Œç¨‹åºçš„è®¡ç®—æœºæ¶æ„ï¼šåœ¨ 64 ä½æ¶æ„ä¸Šï¼Œå®ƒä»¬æ˜¯ 64 ä½çš„ï¼Œåœ¨ 32 ä½æ¶æ„ä¸Šï¼Œå®ƒä»¬æ˜¯ 32 ä½çš„ã€‚åˆ†åˆ«ç­‰ä»·äº `i64` `i32` ä¸ `u64` å’Œ `u32`ã€‚

é™¤äº†é€šè¿‡ç±»å‹æŒ‡å®šå˜é‡çš„æ•´å‹ç±»å‹ï¼Œè¿˜å¯ä»¥ä»¥åç¼€å½¢å¼ä½¿ç”¨ç±»å‹ï¼Œä¾‹å¦‚ `let x = 57u8;`ã€‚è¿˜å¯ä»¥é€šè¿‡æ•°å­—å­—é¢å€¼æ¥æŒ‡å®šç±»å‹ï¼š

`1000` ä¸ `1_000` ç­‰ä»·ï¼Œä½†åè€…æ›´æ˜“è¯»ã€‚

| æ•°å­—å­—é¢å€¼                | ä¾‹å­         |
|------------------------|------------|
| Decimal (åè¿›åˆ¶)         | 98_222     |
| Hex (åå…­è¿›åˆ¶)           | 0xff       |
| Octal (å…«è¿›åˆ¶)           | 0o77       |
| Binary (äºŒè¿›åˆ¶)          | 0b1111_0000 |
| Byte (å•å­—èŠ‚å­—ç¬¦)(ä»…é™äºu8) | b'A'        |

##### æµ®ç‚¹å‹

åœ¨ Rust ä¸­æœ‰ä¸¤ä¸ªåŸç”Ÿæµ®ç‚¹æ•°ç±»å‹ï¼š

- `f32` å•ç²¾åº¦æµ®ç‚¹æ•°ï¼Œå  32 ä½
- `f64` åŒç²¾åº¦æµ®ç‚¹æ•°ï¼Œå  64 ä½ï¼Œç°ä»£ CPU ä¸­ï¼Œå®ƒä¸ `f32` é€Ÿåº¦å‡ ä¹ä¸€æ ·ï¼Œä¸è¿‡ç²¾åº¦æ›´é«˜

æµ®ç‚¹æ•°éƒ½æ˜¯æœ‰ç¬¦å·çš„ã€‚

```rs
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

Rust ä¸­çš„æ‰€æœ‰æ•°å­—ç±»å‹éƒ½æ”¯æŒåŸºæœ¬æ•°å­¦è¿ç®—ï¼šåŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•ã€é™¤æ³•å’Œå–ä½™ã€‚æ•´æ•°é™¤æ³•ä¼šå‘é›¶èˆå…¥åˆ°æœ€æ¥è¿‘çš„æ•´æ•°ï¼š

```rs
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // ç»“æœä¸º -1

    // remainder
    let remainder = 43 % 5;
}
```

##### å¸ƒå°”å‹

```rs
let t = true;
let f: bool = false;
```

##### å­—ç¬¦ç±»å‹

Rust çš„ `char` ç±»å‹æ˜¯è¯­è¨€æœ€åŸç”Ÿçš„å­—æ¯ç±»å‹ï¼Œå¤§å°ä¸ºå››ä¸ªå­—èŠ‚ï¼š

```rs
fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // æ˜¾å¼ç±»å‹å£°æ˜
    let heart_eye_cat = 'ğŸ˜»';
}
```

#### å¤åˆç±»å‹ï¼ˆcompoundï¼‰

å¤åˆç±»å‹ï¼ˆCompound typesï¼‰å¯ä»¥å°†å¤šä¸ªå€¼ç»„åˆæˆä¸€ä¸ªç±»å‹ã€‚Rust æœ‰ä¸¤ä¸ªåŸç”Ÿçš„å¤åˆç±»å‹ï¼šå…ƒç»„ï¼ˆtupleï¼‰å’Œæ•°ç»„ï¼ˆarrayï¼‰ã€‚

##### å…ƒç»„ç±»å‹

å…ƒç»„æ˜¯ä¸€ä¸ªå°†å¤šä¸ªå…¶ä»–ç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªå¤åˆç±»å‹çš„ä¸»è¦æ–¹å¼ã€‚å…ƒç»„é•¿åº¦å›ºå®šï¼šä¸€æ—¦å£°æ˜ï¼Œå…¶é•¿åº¦ä¸ä¼šå¢å¤§æˆ–ç¼©å°ã€‚

```rs
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼ˆpattern matchingï¼‰æ¥è§£æ„ï¼ˆdestructureï¼‰å…ƒç»„å€¼ï¼š

```rs
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("{}", y); // 6.4
}
```

ä¹Ÿå¯ä»¥ç›´æ¥ç”¨ `.` è·Ÿéšå€¼çš„ç´¢å¼•æ¥è®¿é—®å…ƒç»„ä¸­çš„å…ƒç´ ï¼š

```rs
fn main() {
    let tup = (500, 6.4, 1);
    
    let x = tup.0;
    let y = tup.1;
    let z = tup.2;

    println!("{}", x); // 500
}
```

ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„æœ‰ä¸ªç‰¹æ®Šçš„åç§°ï¼Œå«åš å•å…ƒï¼ˆunitï¼‰ å…ƒç»„ã€‚è¿™ç§å€¼ä»¥åŠå¯¹åº”çš„ç±»å‹éƒ½å†™ä½œ `()`ï¼Œè¡¨ç¤º**ç©ºå€¼æˆ–ç©ºçš„è¿”å›ç±»å‹**ã€‚å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œåˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼ã€‚

##### æ•°ç»„ç±»å‹

ä¸å…ƒç»„ä¸åŒï¼Œæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒã€‚

**Rust ä¸­çš„æ•°ç»„é•¿åº¦æ˜¯å›ºå®šçš„ã€‚**

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

å½“ä½ æƒ³è¦åœ¨æ ˆï¼ˆstackï¼‰è€Œä¸æ˜¯åœ¨å †ï¼ˆheapï¼‰ä¸Šä¸ºæ•°æ®åˆ†é…ç©ºé—´ï¼ˆç¬¬å››ç« å°†è®¨è®ºæ ˆä¸å †çš„æ›´å¤šå†…å®¹ï¼‰ï¼Œæˆ–è€…æ˜¯æƒ³è¦ç¡®ä¿æ€»æ˜¯æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ æ—¶ï¼Œæ•°ç»„éå¸¸æœ‰ç”¨ã€‚

ä½†æ˜¯æ•°ç»„å¹¶ä¸å¦‚ `vector` ç±»å‹çµæ´»ã€‚

`vector` ç±»å‹æ˜¯æ ‡å‡†åº“æä¾›çš„ä¸€ä¸ª å…è®¸ å¢é•¿å’Œç¼©å°é•¿åº¦çš„ç±»ä¼¼æ•°ç»„çš„é›†åˆç±»å‹ã€‚å½“ä¸ç¡®å®šæ˜¯åº”è¯¥ä½¿ç”¨æ•°ç»„è¿˜æ˜¯ vector çš„æ—¶å€™ï¼Œé‚£ä¹ˆå¾ˆå¯èƒ½åº”è¯¥ä½¿ç”¨ `vector`ã€‚

ç„¶è€Œï¼Œå½“ä½ **ç¡®å®šå…ƒç´ ä¸ªæ•°ä¸ä¼šæ”¹å˜æ—¶ï¼Œæ•°ç»„ä¼šæ›´æœ‰ç”¨**ã€‚

ä¾‹å¦‚ï¼Œå½“ä½ åœ¨ä¸€ä¸ªç¨‹åºä¸­ä½¿ç”¨æœˆä»½åå­—æ—¶ï¼Œä½ æ›´åº”è¶‹å‘äºä½¿ç”¨æ•°ç»„è€Œä¸æ˜¯ `vector`ï¼Œå› ä¸ºä½ ç¡®å®šåªä¼šæœ‰ 12 ä¸ªå…ƒç´ ã€‚

```rs
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

å£°æ˜æ•°ç»„æ—¶ï¼Œå¯ä»¥åƒè¿™æ ·ç¼–å†™æ•°ç»„çš„ç±»å‹ï¼Œæ—¢èƒ½çº¦æŸæ•°ç»„ä¸­å…ƒç´ çš„ç±»å‹ï¼Œè¿˜èƒ½é™åˆ¶æ•°ç»„çš„é•¿åº¦ï¼š

```rs
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

è¿™é‡Œçš„ `i32` ä»£è¡¨æ¯ä¸ªå…ƒç´ çš„ç±»å‹ï¼Œåˆ†å·ä¹‹åçš„ `5` ä»£è¡¨æ•°ç»„çš„é•¿åº¦ä¸º 5ï¼ŒåŒ…å«äº”ä¸ªå…ƒç´ ã€‚

è¿˜å¯ä»¥åœ¨ç±»å‹å£°æ˜ä¸­æŒ‡å®šåˆå§‹å€¼ï¼š

```rs
let b: [3, 5];
```

è¿™æ ·å˜é‡ `b` å°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 5ï¼Œåˆå§‹å€¼å…¨ä¸º 3 çš„æ•°ç»„ã€‚

æ•°ç»„æ˜¯å¯ä»¥åœ¨æ ˆ (stack) ä¸Šåˆ†é…çš„å·²çŸ¥å›ºå®šå¤§å°çš„å•ä¸ªå†…å­˜å—ã€‚å¯ä»¥ä½¿ç”¨ç´¢å¼•æ¥è®¿é—®æ•°ç»„çš„å…ƒç´ ï¼Œåƒè¿™æ ·ï¼š

```rs
let c = [1, 2, 3, 4, 5];

let x = c[0]; // 1
let y = c[1]; // 2
```

é€šè¿‡ç´¢å¼•ä»æ•°ç»„ä¸­å–å€¼çš„æ“ä½œå¦‚æœæ˜¯åœ¨è¿è¡Œæ—¶è¿›è¡Œçš„ï¼Œé‚£ä¹ˆä»£ç å¯ä»¥é¡ºåˆ©é€šè¿‡ç¼–è¯‘ï¼Œä½†åœ¨è¿è¡Œæ—¶ä¼šå‡ºé”™ï¼š

ä¸‹é¢è¿™æ®µä»£ç å¯ä»¥æ­£å¸¸é€šè¿‡ç¼–è¯‘ï¼Œå½“ä½ è¾“å…¥ 0 1 2 3 4 è®¿é—®æ•°ç»„æ—¶å·¥ä½œæ­£å¸¸ï¼Œä½†ä¸€æ—¦è¾“å…¥äº†è¶…è¿‡æ•°ç»„é•¿åº¦çš„ç´¢å¼•å¦‚ 10ï¼Œå°±ä¼šæŠ›å‡ºé”™è¯¯ã€‚

```rs
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

```sh
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

### å‡½æ•°

- å¿…é¡»æ˜¾å¼æŒ‡å®šå‚æ•°çš„ç±»å‹
- é€šè¿‡ `->` æŒ‡å®šè¿”å›å€¼çš„ç±»å‹
- å‡½æ•°ç»“å°¾ä¸åŒ…å«åˆ†å·æ—¶ï¼Œéšå¼è¿”å›è¡¨è¾¾å¼

```rs
fn main() {
    print_labeled_measurement(188, 's');

    let f: i32 = five();
    println!("five: {}", f);
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}

fn five() -> i32 {
    // ç»“å°¾ä¸åŒ…å«åˆ†å· éšå¼è¿”å›è¡¨è¾¾å¼
    5
}
```

### æ§åˆ¶æµ

#### if-else & else-if

- å¯ä»¥çœç•¥ if ä¸æ¡ä»¶ä¹‹é—´çš„ç©ºæ ¼
- ä¸å…è®¸éšå¼è½¬æ¢

```rs
fn main() {
    let number = 3;

    if number < 5 {
        println!("Yes.");
    } else {
        println!("No.");
    }
}
```

```rs
// ä¸å…è®¸éšå¼è½¬æ¢ æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼
if number {
    println!("Yes.");
}

if number != 0 {
    println!("Yes.");
}
```

`if` å¯ä»¥è¿”å›ä¸€ä¸ªå€¼ï¼Œå› æ­¤å¯ä»¥åœ¨ `let` è¯­å¥ä¸­ä½¿ç”¨ `if`ï¼š

```rs
fn main() {
    let condition = true;
    // if ä¸ else åˆ†æ”¯çš„ç»“æœéƒ½ä¸º i32
    let number = if condition { 5 } else { 6 };

    println!("number: {}", number);
}
```

ç”±äºç±»å‹å¿…é¡»åœ¨ç¼–è¯‘æ—¶è¢«ç¡®å®šï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è¯†åˆ«å‡ºä¸ç¬¦åˆè¿™ä¸€åŸåˆ™çš„ if-in-let å£°æ˜ï¼š

```rs
fn main() {
    // ç¼–è¯‘æŠ¥é”™ å› ä¸º if ä¸ else åˆ†æ”¯çš„ç»“æœç±»å‹ä¸åŒ
    let number = if condition { 5 } else { "six" }
}
```

#### å¾ªç¯

- `break;` ç”¨äºä¸­æ­¢å¾ªç¯
- `continue;` ç”¨äºè·³è¿‡å½“æ¬¡å¾ªç¯
- `break;` å¯ä»¥ä»å¾ªç¯è¿”å›è¡¨è¾¾å¼

```rs
fn main() {
    let mut count = 0;

    let result = loop {
        count += 1;

        if (count == 10) {
            break count * 2;
        }
    }

    println!("result: {}", result); // 20
}
```

å¾ªç¯æ ‡ç­¾ï¼šåœ¨å¤šä¸ªå¾ªç¯ä¹‹é—´æ¶ˆé™¤æ­§ä¹‰

å¦‚æœä½ å­˜åœ¨ä¸€ä¸ªåµŒå¥—çš„å¾ªç¯ï¼Œè€Œ `break;` ä¸ `continue;` åªä¼šåº”ç”¨äºæ­¤æ—¶æœ€å†…å±‚çš„å¾ªç¯ï¼Œå¯ä»¥é€šè¿‡å¾ªç¯æ ‡ç­¾æ¥è®©è¿™äº›å…³é”®å­—åº”ç”¨äºå·²æ ‡è®°çš„å¾ªç¯ï¼š

```rs
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œç¬¬ä¸€ä¸ª `break;` è¯­å¥åªä¼šé€€å‡ºå†…å±‚å¾ªç¯ï¼Œè€Œ `break 'counting_up';` è¯­å¥å°†ç›´æ¥é€€å‡ºå¤–å±‚å¾ªç¯ã€‚

é™¤äº† `loop`ï¼ŒRust è¿˜æ”¯æŒé€šè¿‡ `while` æ¥æ§åˆ¶å¾ªç¯ï¼š

```rs
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

å½“æˆ‘ä»¬è¦å®ç°éå†é›†åˆä¸­çš„å…ƒç´ æ—¶ï¼Œç”¨ `for` ä¼šæ›´æ–¹ä¾¿ï¼š

```rs
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("value is {}", a);
    }
}
```

`for` äº¦å¯ç”¨äºè®¡æ—¶ï¼š

è¿™æ®µä»£ç ä¸­ç”¨åˆ°äº† `.rev()` æ–¹æ³•æ¥å°† range åè½¬

```rs
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

## æ‰€æœ‰æƒ

### ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒ

Rust çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€å°±æ˜¯**æ‰€æœ‰æƒ**ï¼ˆownershipï¼‰ã€‚

æ‰€æœ‰ç¨‹åºéƒ½å¿…é¡»ç®¡ç†å…¶è¿è¡Œæ—¶ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼ï¼š

- ä¸€äº›è¯­è¨€å…·æœ‰åƒåœ¾å›æ”¶æœºåˆ¶ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶æœ‰è§„å¾‹åœ°å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ï¼›
- åœ¨å¦ä¸€äº›è¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜å¿…é¡»äº²è‡ªåˆ†é…å’Œé‡Šæ”¾å†…å­˜ï¼›
- Rust åˆ™é€‰æ‹©äº†ç¬¬ä¸‰ç§æ–¹å¼ï¼Œé€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿç®¡ç†å†…å­˜

ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šæ ¹æ®ä¸€ç³»åˆ—çš„è§„åˆ™è¿›è¡Œæ£€æŸ¥ï¼Œå¦‚æœè¿åäº†ä»»ä½•è¿™äº›è§„åˆ™ï¼Œç¨‹åºéƒ½ä¸èƒ½ç¼–è¯‘ã€‚

- Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼ˆownerï¼‰ï¼›
- å€¼åœ¨ä»»ä¸€æ—¶åˆ»åªæœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼›
- å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼ä¼šè¢«ä¸¢å¼ƒã€‚

```rs
{
    // s å°šæœªè¢«å£°æ˜ æ— æ³•è®¿é—®
    let s = "Hello"; // åœ¨æ­¤å¤„èµ· s æ˜¯æœ‰æ•ˆçš„
    // å£°æ˜å åœ¨ä½œç”¨åŸŸå†… ä½ å¯ä»¥ä½¿ç”¨ s
}
// ä½œç”¨åŸŸå¤– s è¢«é”€æ¯ï¼Œä½¿ç”¨ s æ˜¯ä¸è¢«å…è®¸çš„
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­æœ‰ä¸¤ä¸ªé‡è¦çš„æ—¶é—´ç‚¹ï¼š

- s **è¿›å…¥ä½œç”¨åŸŸ**æ—¶ï¼Œå®ƒæ˜¯æœ‰æ•ˆçš„
- è¿™ä¸€ç›´æŒç»­åˆ°å®ƒ**ç¦»å¼€ä½œç”¨åŸŸ**ä¸ºæ­¢

ä¸ºäº†æ¼”ç¤ºæ‰€æœ‰æƒçš„è§„åˆ™ï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥ä¸€ä¸ªå­˜å‚¨åœ¨å †ä¸Šçš„æ•°æ®ç±»å‹

ä¹‹å‰ç”±å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»ºå­—ç¬¦ä¸²æ—¶ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µå°±çŸ¥é“å…¶å†…å®¹ï¼Œè¿™éƒ¨åˆ†å†…å®¹è¢«ç¡¬ç¼–ç å­˜å‚¨åœ¨æœ€ç»ˆçš„ç¼–è¯‘ç»“æœä¸­ã€‚

ä½†é€šè¿‡ `String` åˆ›å»ºçš„å­—ç¬¦ä¸²ï¼Œæ­¤ç±»å‹ç®¡ç†è¢«åˆ†é…åˆ°å †ä¸Šçš„æ•°æ®ï¼Œæ‰€ä»¥èƒ½å¤Ÿå­˜å‚¨åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„æ–‡æœ¬ï¼š

```rs
let s = String::from("Hello");
```

åŒå†’å· `::` æ˜¯ä¸€ç§è¿ç®—ç¬¦ï¼Œå®ƒå…è®¸å°†ç‰¹å®šçš„ `from` å‡½æ•°ç½®äº `String` ç±»å‹çš„å‘½åç©ºé—´ï¼ˆnamespaceï¼‰ä¸‹ï¼Œè€Œä¸éœ€è¦ä½¿ç”¨å¦‚ `string_from` è¿™æ ·çš„åå­—ã€‚

å¯ä»¥ä¿®æ”¹æ­¤ç±»å­—ç¬¦ä¸²ï¼š

```rs
let mut s = String::from("Hello");
s.push_str(", World!"); // åœ¨ s åè¿½åŠ å­—é¢å€¼
println!("s: {}", s); // "Hello, World!"
```

ä¸åŒäºé€šè¿‡å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»ºçš„å­—ç¬¦ä¸²ï¼Œæ­¤ç±»å­—ç¬¦ä¸²å¯ä»¥è¢«ä¿®æ”¹ã€‚è¿™æ˜¯å› ä¸ºä¸¤ç§ç±»å‹åœ¨å†…å­˜ä¸Šçš„å¤„ç†ä¸åŒï¼š

- é€šè¿‡å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»ºçš„å­—ç¬¦ä¸²ï¼šè¢«ç¡¬ç¼–ç è¿›æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œè¿™ä½¿å¾—å­—ç¬¦ä¸²å­—é¢å€¼å¿«é€Ÿä¸”é«˜æ•ˆï¼Œä½†ä»£ä»·æ˜¯å®ƒçš„ä¸å¯å˜æ€§ã€‚
- `String` ç±»å‹ä¸ºäº†æ”¯æŒå¯å˜ã€å¯å¢é•¿çš„æ–‡æœ¬ç‰‡æ®µï¼Œéœ€è¦åœ¨å †ä¸Šåˆ†é…ä¸€å—åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„å†…å­˜æ¥å­˜æ”¾å†…å®¹

1. å¿…é¡»åœ¨è¿è¡Œæ—¶å‘å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰è¯·æ±‚å†…å­˜
2. éœ€è¦ä¸€ä¸ªå½“æˆ‘ä»¬å¤„ç†å®Œ `String` æ—¶å°†å†…å­˜è¿”å›ç»™åˆ†é…å™¨çš„æ–¹æ³•

å¯¹äº 1. æˆ‘ä»¬å·²ç»é€šè¿‡ `String::from` å®Œæˆï¼Œç„¶è€Œå¯¹äº 2. åœ¨ Rust ä¸­åˆ™æ˜¯é‡‡ç”¨è¿™æ ·çš„ç­–ç•¥ï¼šå†…å­˜åœ¨æ‹¥æœ‰å®ƒçš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶å°±è¢«è‡ªåŠ¨é‡Šæ”¾ï¼š

```rs
{
    let s = String::from("Hello");
} // ä½œç”¨åŸŸç»“æŸ
// æ­¤æ—¶ s ä¸å†æœ‰æ•ˆ
```

è¿™æ˜¯ä¸€ä¸ªå°† `String` éœ€è¦çš„å†…å­˜è¿”å›ç»™åˆ†é…å™¨çš„å¾ˆè‡ªç„¶çš„ä½ç½®ï¼šå½“ `s` ç¦»å¼€ä½œç”¨åŸŸçš„æ—¶å€™ã€‚å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼ŒRust ä¸ºæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å«åš `drop`ï¼Œåœ¨è¿™é‡Œ `String` çš„ä½œè€…å¯ä»¥æ”¾ç½®é‡Šæ”¾å†…å­˜çš„ä»£ç ã€‚Rust åœ¨ç»“å°¾çš„ `}` å¤„è‡ªåŠ¨è°ƒç”¨ `drop`ã€‚

ä»¥æ•´å‹æ•°æ®ä¸ºä¾‹ï¼ŒåŒä¸€æ•°æ®å¯ä»¥è¢«ä¸åŒçš„å˜é‡ç»‘å®šï¼š

```rs
let x = 5;
let y = x;
```

å°† `5` ç»‘å®šåˆ°å˜é‡ `x`ï¼Œç”Ÿæˆä¸€ä¸ªå€¼ `x` çš„æ‹·è´å¹¶ç»‘å®šåˆ°å˜é‡ `y` ä¸Šï¼Œå› ä¸ºæ•´å‹æ˜¯å·²çŸ¥å›ºå®šå¤§å°çš„ç®€å•å€¼ï¼Œæ‰€ä»¥ä¸¤ä¸ª `5` éƒ½è¢«æ”¾å…¥äº†æ ˆä¸­ã€‚

å†ä¸¾ä¸€ä¸ª `String` ç‰ˆæœ¬çš„ä¾‹å­ï¼š

```rs
let s1 = String::from("Hello");
let s2 = s1;
```

è™½ç„¶åšçš„äº‹æƒ…æ˜¯ä¸€æ ·çš„ï¼Œä½†å†…å­˜åˆ†é…ä¸Šå®Œå…¨ä¸åŒï¼š

![s1è¢«æ ‡è®°ä¸ºæ— æ•ˆçš„å†…å­˜è¡¨ç°](./Rust.assets/trpl04-04.svg)

- å¦‚æœ `s1` æœªè¢«é”€æ¯ï¼Œä¸¤ä¸ªå˜é‡æŒ‡å‘äº†åŒä¸€ä¸ªå†…å­˜ç©ºé—´ï¼Œå­˜åœ¨äºŒæ¬¡é‡Šæ”¾çš„é£é™©ï¼›
- å¦‚æœé‡æ–°å¼€è¾Ÿæ–°çš„å†…å­˜ç©ºé—´è¢«å¼€è¾Ÿï¼Œä¼šå¸¦æ¥æ€§èƒ½é—®é¢˜ï¼›

å› æ­¤ï¼Œå½“æ‰§è¡Œ `s2 = s1` æ—¶ï¼Œä¸ä¼šæœ‰æ–°çš„å†…å­˜ç©ºé—´è¢«å¼€è¾Ÿï¼Œ`s1` è¢«æ ‡è®°ä¸ºæ— æ•ˆï¼Œä¸å†å…è®¸è¢«ä½¿ç”¨ï¼Œ`s2` æ˜¯æœ‰æ•ˆçš„ï¼Œå½“å…¶ç¦»å¼€è‡ªå·±çš„ä½œç”¨åŸŸå°±é‡Šæ”¾è‡ªå·±çš„å†…å­˜ã€‚

Rust æ°¸è¿œä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„â€œæ·±æ‹·è´â€ï¼Œå› æ­¤ä»»ä½•è‡ªåŠ¨çš„å¤åˆ¶éƒ½ä¼šè¢«è®¤ä¸ºæ˜¯å¯¹è¿è¡Œæ—¶æ€§èƒ½å½±å“è¾ƒå°çš„ã€‚

å¦‚æœæˆ‘ä»¬ç¡®å®éœ€è¦æ·±åº¦å¤åˆ¶ `String` ä¸­å †ä¸Šçš„æ•°æ®ï¼Œè€Œä¸ä»…ä»…æ˜¯æ ˆä¸Šçš„æ•°æ®ï¼Œå¯ä»¥æ˜¾å¼è°ƒç”¨ `clone` æ–¹æ³•ã€‚

```rs
let s1 = String::from("Hello");
let s2 = s1.clone();

println!("s1: {}, s2: {}", s1, s2); // s1 ä¸ s2 éƒ½å¯ç”¨
```

åœ¨ Rust ä¸­æœ‰ä¸€ç§ `Copy` trait çš„ç‰¹æ®Šæ³¨è§£ï¼šå¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy` traitï¼Œé‚£ä¹ˆä¸€ä¸ªæ—§çš„å˜é‡åœ¨å°†å…¶èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨ã€‚

`Drop` trait ä¸ `Copy` trait æ˜¯äº’æ–¥çš„ï¼Œä¸€ä¸ªé€šç”¨çš„é‰´åˆ«ç±»å‹æ˜¯ä¸æ˜¯å®ç°äº† Copy trait çš„æ–¹æ³•æ˜¯ï¼š

ä»»ä½•ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®ç° `Copy`ï¼Œä»»ä½•ä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹éƒ½å¯ä»¥å®ç° `Copy`ï¼Œå¦‚ï¼š

intã€boolã€floatã€charã€tuple

### å¼•ç”¨ä¸å€Ÿç”¨

### Slice ç±»å‹

```rs
fn main() {

    {
        let s = String::from("Hello");
        takes_ownership(s);

        // s had been moved
        // println!("{}", s);

        let x = 5;
        makes_copy(x);
        println!("{}", x); // x is still avaliable(copied)

        fn takes_ownership(some_string: String) {
            println!("{}", some_string);
        }

        fn makes_copy(some_integer: i32) {
            println!("{}", some_integer);
        }
    }

    {
        let s1 = gives_ownership();
        let s2 = String::from("Hello");
        let s3 = takes_and_gives_back(s2);

        // s2 ä¸å¯è®¿é—® å› å…¶æ‰€æœ‰æƒå·²ç»è½¬ç§»ç»™äº† s3
        println!("s1: {}, s3: {}", s1, s3);

        // å‘å¤–ç•Œæˆäºˆæ‰€æœ‰æƒ
        fn gives_ownership() -> String {
            let some_string = String::from("yours");
            some_string
        }

        // è·å–æ‰€æœ‰æƒå¹¶å‘å¤–æˆäºˆ
        fn takes_and_gives_back(a_string: String) -> String {
            a_string
        }
    }

    {
        let s1 = String::from("Hello");
        let (s2, len) = calculate_length(s1);

        println!("length of {} is {}.", s2, len);

        // è®¡ç®— String çš„é•¿åº¦å¹¶å½’è¿˜æ‰€æœ‰æƒ
        fn calculate_length(some_string: String) -> (String, usize) {
            let size = some_string.len();
            (some_string, size)
        }
    }

    {
        let s1 = String::from("Hello");
        let len = calculate_length(&s1);

        // å°† s1 çš„æŒ‡é’ˆä¼ é€’ç»™å‡½æ•°
        // æ‰€æœ‰æƒä¸ä¼šè¢«è½¬ç§» åœ¨è°ƒç”¨å‡½æ•°å s1 ä»ç„¶å¯ç”¨
        println!("length of {} is {}.", s1, len);

        fn calculate_length(s: &String) -> usize {
            s.len()
        }
    }

    {
        let s = String::from("Hello");
        change(&s);

        fn change(some_string: &String) {
            // æ­¤å¤„æ— æ³•é€šè¿‡ç¼–è¯‘ å› ä¸ºå€Ÿç”¨çš„å˜é‡æ— æ³•è¢«ä¿®æ”¹
            // some_string.push_str("SomeStuff");
            println!("some_string: {}", some_string);
        }
    }

    {
        let mut s = String::from("Hello");
        change(&mut s);
        // å¦‚æœå·²ç»åˆ›å»ºäº†ä¸€ä¸ªå˜ï¥¾çš„å¯å˜å¼•ç”¨
        // å°±ï¥§èƒ½å†åˆ›å»ºå¯¹è¯¥å˜ï¥¾çš„å¼•ç”¨ è¿™æ˜¯ä¸ºäº†é˜²æ­¢ data race
        println!("s had been changed to: {}.", s);
        
        fn change(some_string: &mut String) {
            some_string.push_str("SomeStuff");
        }
    }

    {
        let mut s = String::from("Hello");

        // å½“ç„¶ åœ¨ä¸åŒçš„ä½œç”¨åŸŸä¸­ å¯ä»¥åˆ›å»ºä¸åŒçš„å¯å˜å¼•ç”¨
        {
            let r1 = &mut s;
            r1.push_str("SomeStuff");
        }
        {
            let r2 = &mut s;
            r2.push_str("SomeStuff");
        }

        // ä½†æ˜¯ ä¸èƒ½åŒæ—¶æ‹¥æœ‰ä¸å¯å˜å¼•ç”¨ä¸å¯å˜å¼•ç”¨ï¼Œæˆ–åŒæ—¶æ‹¥æœ‰å¤šä¸ªå¯å˜å¼•ç”¨
        {
            let _r1 = &s;
            // let r2 = &mut s;
            // println!("r1: {}, r2: {}", r1, r2);
        }
        {
            let _r1 = &mut s;
            // let r2 = &mut s;
            // println!("r1: {}, r2: {}", r1, r2);
        }

        // åªè¦ä¿è¯ã€Œä¸åŒæ—¶ã€å³å¯
        {
            let r1 = &s;
            println!("r1: {}", r1);

            // r1 å€Ÿç”¨å®Œæ¯• r2 å¯ä»¥æ­£å¸¸å¼•ç”¨å¹¶ä½¿ç”¨ s çš„å¼•ç”¨
            let r2 = &mut s;
            println!("r2: {}", r2);
        }
    }

    {
        // æ‚¬å‚å¼•ç”¨ (Dangling References)
        let reference_to_nothing = dangle();
        println!("reference_to_nothing: {}", reference_to_nothing);

        // fn dangle() -> &String {
        //     // åˆ›å»ºå­—ç¬¦ä¸² s
        //     let s = String::from("");

        //     // è¿”å›å­—ç¬¦ä¸²çš„å¼•ç”¨ &s
        //     &s
        // } // ä½œç”¨åŸŸç»“æŸ s è¢«ä¸¢å¼ƒ å æ®çš„å†…å­˜è¢«é‡Šæ”¾

        fn dangle() -> String {
            let s = String::from("");

            // è¿”å› String å æ‰€æœ‰æƒè¢«ç§»åŠ¨å‡ºå‡½æ•° å› æ­¤å€¼ä¸ä¼šè¢«é‡Šæ”¾
            s
        }
    }

    {
        let words = String::from("Hello World!");
        let result = first_word(&words);

        println!("result: {}", result);

        fn first_word(s: &String) -> usize {
            let bytes = s.as_bytes();

            for(i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return i;
                }
            }

            s.len()
        }
    }

    {
        let s = String::from("Hello, World!");
        let hello = &s[..5];
        let world = &s[6..];
        println!("{}, {}", hello, world);

        let words = String::from("Hello, World!");
        let result = first_word(&words);
        println!("result: {}", result);

        fn first_word(s: &String) -> &str {
            let bytes = s.as_bytes();

            for (i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return &s[..i];
                }
            }

            &s[..]
        }
    }
}
```

## ç»“æ„ä½“

`struct` æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œå…è®¸ä½ åŒ…è£…å’Œå‘½åå¤šä¸ªç›¸å…³çš„å€¼ï¼Œä»è€Œå½¢æˆä¸€ä¸ªæœ‰æ„ä¹‰çš„ç»„åˆã€‚

### ç»“æ„ä½“çš„å®šä¹‰ä¸åˆå§‹åŒ–

ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªç”¨äºå­˜å‚¨ç”¨æˆ·è´¦å·ä¿¡æ¯çš„ç»“æ„ä½“ï¼š

```rs
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64
}
```

è¦ä½¿ç”¨å®ƒï¼Œéœ€è¦å°†å…¶å®ä¾‹åŒ–ï¼š

```rs
fn main() {
    let user1 = User {
        active: true,
        username: String::from("Ziu"),
        email: String::from("ziu@email.com"),
        sign_in_count: 1,
    };
}
```

é»˜è®¤æƒ…å†µä¸‹ç»“æ„ä½“ä¸­çš„å€¼æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚æœè¦ä¿®æ”¹æŸä¸ªå­—æ®µï¼Œéœ€è¦å°†**ç»“æ„ä½“å®ä¾‹æ ‡è®°ä¸ºå¯å˜çš„**ï¼ˆRust ä¸å…è®¸å°†æŸä¸€ä¸ªå­—æ®µæ ‡è®°ä¸ºå¯å˜çš„ï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡ `.` è¯­æ³•å¯¹å®ä¾‹ä¸­çš„å€¼åšä¿®æ”¹ï¼š

```rs
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("Ziu"),
        email: String::from("ziu@email.com"),
        sign_in_count: 1,
    };

    user1.sign_in_count += 1;
}
```

å¯ä»¥é€šè¿‡å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•æ¥åˆ›å»ºå®ä¾‹ï¼š

```rs
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        email,
        username,
        sign_in_count: 1
    }
}
```

ç”¨ç»“æ„æ›´æ–°è¯­æ³•ä½¿ç”¨æ›´å°‘çš„ä»£ç æ¥åˆ›å»ºæ–° `User` å®ä¾‹ï¼š

åˆ›å»ºä¸€ä¸ªæ–°çš„ `User` å®ä¾‹ `user2`ï¼Œå…¶ä¸­ `email` å­—æ®µæ˜¯æ–°çš„å€¼ï¼Œå…¶ä½™å­—æ®µæ¥è‡ª `user1`ã€‚

```rs
fn main() {
    let user2 = User {
        email: String::from("user2@email.com"),
        ..user1
    };
}
```

::: warning
ç»“æ„æ›´æ–°è¯­æ³•å°±åƒ `=` èµ‹å€¼ä¸€æ ·éµå¾ªæ‰€æœ‰æƒè½¬ç§»è§„åˆ™ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`user2` è¢«åˆ›å»ºåæˆ‘ä»¬å°±ä¸èƒ½å†ä½¿ç”¨ `user1` äº†ï¼Œè¿™æ˜¯å› ä¸º `user1` çš„ `username` å­—æ®µä¸­çš„ `String` å€¼è¢«è½¬ç§»åˆ°äº† `user2` ä¸­ã€‚

å¦‚æœæˆ‘ä»¬ç»™ `user2` çš„ `username` ä¸ `email` éƒ½èµ‹æ–°å€¼ï¼Œåªæœ‰ `active` å’Œ `sign_in_count` è¢«å¤ç”¨ï¼Œé‚£ä¹ˆ `user1` ä»å¯ç”¨ã€‚
:::

å…ƒç»„ç»“æ„ä½“ï¼ˆtuple structsï¼‰ä¸­å¯ä»¥é€šè¿‡ `struct` å…³é”®å­—å®šä¹‰ï¼Œä½†æ²¡æœ‰å…·ä½“çš„å­—æ®µåï¼Œåªæœ‰å­—æ®µçš„ç±»å‹

å½“ä½ æƒ³ç»™å…ƒç»„å–ä¸€ä¸ªåå­—ï¼Œå¹¶ä½¿å…ƒç»„æˆä¸ºä¸å…¶ä»–å…ƒç»„ä¸åŒçš„ç±»å‹æ—¶ï¼Œå…ƒç»„ç»“æ„ä½“æ˜¯å¾ˆæœ‰ç”¨çš„ï¼š

```rs
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç±»å•å…ƒç»“æ„ä½“ï¼Œç±»ä¼¼äº `()` å³å…ƒç¥–ç±»å‹ä¸­çš„ unit ç±»å‹ã€‚

å¸¸ç”¨è¯­ä½ æƒ³è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç° trait ä½†ä¸éœ€è¦åœ¨ç±»å‹ä¸­å­˜å‚¨æ•°æ®æ—¶å‘æŒ¥ä½œç”¨ã€‚

å£°æ˜å¹¶å®ä¾‹åŒ–ä¸€ä¸ªåä¸º `AlwaysEqual` çš„ unit ç»“æ„çš„ä¾‹å­ï¼š

```rs
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

::: info
ç»“æ„ä½“æ•°æ®çš„æ‰€æœ‰æƒ

å‰é¢ `User` çš„ä¾‹å­ä¸­ï¼Œ`username` ä¸ `email` å­—æ®µéƒ½æŒæœ‰ `String` ç±»å‹çš„æ•°æ®è€Œä¸æ˜¯å…¶å¼•ç”¨ã€‚

åŒæ—¶ï¼Œç»“æ„ä½“ä¹Ÿå¯ä»¥å­˜å‚¨è¢«å…¶ä»–å¯¹è±¡æ‹¥æœ‰çš„æ•°æ®çš„å¼•ç”¨ï¼Œä¸è¿‡è¦è¿™æ ·åšçš„è¯å°±å¿…é¡»å¼•å…¥**ç”Ÿå‘½å‘¨æœŸ**è¿™ä¸ªæ¦‚å¿µã€‚

ç”Ÿå‘½å‘¨æœŸç¡®ä¿ç»“æ„ä½“å¼•ç”¨çš„æ•°æ®æœ‰æ•ˆæ€§å’Œç»“æ„ä½“æœ¬èº«ä¿æŒä¸€è‡´ã€‚å¦‚æœä½ å°è¯•åœ¨ç»“æ„ä½“ä¸­å­˜å‚¨ä¸€ä¸ªå¼•ç”¨è€Œä¸æŒ‡å®šç”Ÿå‘½å‘¨æœŸå°†æ˜¯æ— æ•ˆçš„ï¼š

```rs
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}
```

æ‰§è¡Œç¼–è¯‘æ—¶ï¼Œç¼–è¯‘å™¨å°†ä¼šæŠ›å‡ºé”™è¯¯ï¼šéœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡è¯†ç¬¦
:::

### ç¤ºä¾‹

ä¸‹é¢å†™ä¸€ä¸ªè®¡ç®—é•¿æ–¹å½¢é¢ç§¯çš„ç¨‹åºæ¥ç†è§£ä½•æ—¶éœ€è¦ä½¿ç”¨ç»“æ„ä½“ï¼š

```rs
fn main() {
    let width = 30;
    let height = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width, height)
    );

    fn area(width: u32, height: u32) -> u32 {
        width * height
    }
}
```

é€šè¿‡å…ƒç»„ç»™å‡½æ•°å…¥å‚å»ºç«‹å…³è”ï¼š

```rs
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

ç”¨ç»“æ„ä½“ç»™å‚æ•°èµ‹äºˆæ›´å¤šæ„ä¹‰ï¼Œç»™å‚æ•°æ·»åŠ è¯­ä¹‰åŒ–çš„æ ‡ç­¾ï¼š

```rs
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

å€Ÿç”¨ç»“æ„ä½“çš„æ‰€ç”¨æƒï¼Œå°† `rect1` çš„ä¸å¯å˜å¼•ç”¨ä¼ å…¥ `area` å‡½æ•°ï¼Œé€šè¿‡ `.` è¯­æ³•è®¿é—®ç»“æ„ä½“å­—æ®µä¸ä¼šç§»åŠ¨å­—æ®µçš„æ‰€æœ‰æƒã€‚

åœ¨è°ƒè¯•çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœä½ å°è¯•å°†ç»“æ„ä½“é€šè¿‡ `println!` å®æ‰“å°ï¼Œè¿è¡Œä»£ç æ—¶ä¼šæŠ›å‡ºé”™è¯¯ï¼š

```rs
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```

```sh
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

`println!` å®èƒ½å¤„ç†å¾ˆå¤šç±»å‹çš„æ ¼å¼ï¼Œä½†å½“ä½ ä½¿ç”¨ `{}` å ä½ç¬¦æ—¶ï¼Œé»˜è®¤å‘Šè¯‰ `println!` ä½¿ç”¨è¢«ç§°ä¸º `Display` çš„æ ¼å¼ï¼šç›´æ¥ç»™ç»ˆç«¯ç”¨æˆ·æŸ¥çœ‹çš„è¾“å‡ºã€‚

åŸºæœ¬ç±»å‹éƒ½é»˜è®¤å®ç°äº† `Display`ï¼Œå› ä¸ºå€¼å¾ˆç®€å•ï¼ŒRust å¯ä»¥å¸®æˆ‘ä»¬å®Œæˆè¿™éƒ¨åˆ†å®ç°ã€‚ç„¶è€Œå¯¹äºç»“æ„ä½“çš„å±•ç¤ºå­˜åœ¨å¾ˆå¤šç»†èŠ‚ï¼š

- æ˜¯å¦éœ€è¦ç»“å°¾çš„é€—å·ï¼Ÿ
- éœ€è¦æ‰“å°å‡ºå¤–å±‚å¤§æ‹¬å·å—ï¼Ÿ
- æ‰€æœ‰å­—æ®µéƒ½åº”è¯¥æ˜¾ç¤ºå—ï¼Ÿ

å› æ­¤ Rust å¹¶æ²¡æœ‰åœ¨ç»“æ„ä½“ä¸Šæä¾› `Display` å®ç°æ¥ä½¿ç”¨ `println!` ä¸ `{}` å ä½ç¬¦ã€‚

ä½ å¯ä»¥é€šè¿‡ `Debug` trait è¾“å‡ºæ ¼å¼æ‰“å°ç»“æ„ä½“ï¼Œå°† `{}` å ä½ç¬¦æ›¿æ¢ä¸º `{:?}`ï¼š

```rs
println!("rect1 is {:?}", rect1);
```

åŒæ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æ˜¾å¼åœ°ä¸ºç»“æ„ä½“å¼€å¯è¿™ä¸ªè°ƒè¯•åŠŸèƒ½ï¼š

```rs {1}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

è¿™ä¼šé»˜è®¤å±•ç¤ºæ‰€æœ‰çš„ç»“æ„ä½“ä¸­çš„å­—æ®µï¼š

```sh
rect1 is Rectangle { width: 30, height: 50 }
```

å½“ç»“æ„ä½“å˜å¾—æ›´å¤§ï¼Œæœ‰ä¸€ç§æ›´æ˜“è¯»çš„å ä½ç¬¦å¯ä»¥ä½¿ç”¨ï¼š`{:#?}`

```rs
    println!("rect1 is {:#?}", rect1);
```

è¿™åŒ…å«äº†æ›´æ¼‚äº®çš„æ¢è¡Œä¸ç¼©è¿›ï¼Œè¾“å‡ºçš„è°ƒè¯•ä¿¡æ¯æ›´æ˜“è¯»ã€‚

å¦ä¸€ç§ä½¿ç”¨ `Debug` æ ¼å¼æ‰“å°æ•°å€¼çš„æ–¹æ³•æ˜¯ `dbg!` å®ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼ˆä¸ `println!` å®ç›¸åï¼Œåè€…æ¥æ”¶çš„æ˜¯å¼•ç”¨ï¼‰

æ‰“å°å‡ºä»£ç ä¸­è°ƒç”¨ `dbg!` å®æ—¶æ‰€åœ¨çš„æ–‡ä»¶å’Œè¡Œå·ä»¥åŠè¯¥è¡¨è¾¾å¼çš„ç»“æœå€¼ï¼Œå¹¶è¿”å›è¯¥å€¼å¾—æ‰€æœ‰æƒã€‚

::: warning
æ³¨æ„ï¼šè°ƒç”¨ `dbg!` å®ä¼šæ‰“å°åˆ°æ ‡å‡†é”™è¯¯æ§åˆ¶å°æµï¼ˆ`stderr`ï¼‰ï¼Œä¸ `println!` ä¸åŒï¼Œåè€…ä¼šæ‰“å°åˆ°æ ‡å‡†è¾“å‡ºæ§åˆ¶å°æµï¼ˆ`stdout`ï¼‰ã€‚
:::

ä¸‹é¢æ˜¯ä½¿ç”¨ `dbg!` å®çš„ä¾‹å­ï¼š

```rs
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

```sh
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

### æ–¹æ³•è¯­æ³•

åœ¨å‰é¢çš„ä»£ç ä¸­ï¼Œ`area` å‡½æ•°æ˜¯å•ç‹¬å®ç°çš„ï¼Œä½†å®é™…ä¸Š `area` å‡½æ•°ä¸ç»“æ„ä½“ `Rectangle` æ˜¯å¼ºç›¸å…³çš„ã€‚

è¿™é‡Œæ¶‰åŠåˆ° å‡½æ•°ï¼ˆfunctionï¼‰ ä¸ æ–¹æ³•ï¼ˆmethodï¼‰ çš„ä¸åŒï¼š

ä¸å‡½æ•°ä¸åŒçš„æ˜¯ï¼Œæ–¹æ³•æ˜¯åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡è¢«å®šä¹‰çš„ï¼ˆæˆ–è€…æ˜¯æšä¸¾æˆ– trait å¯¹è±¡çš„ä¸Šä¸‹æ–‡ï¼‰

æˆ‘ä»¬å°†å‰æ–‡ä¸­çš„ `area` å‡½æ•°æ”¹å†™ä¸ºå®šä¹‰äº `Rectangle` ç»“æ„ä½“ä¸Šçš„ä¸€ä¸ª `area` æ–¹æ³•ï¼š

```rs
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

ä¸ºäº†ä½¿å‡½æ•°å®šä¹‰äº `Rectangle` çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `impl` å…³é”®å­—ï¼Œåœ¨ `impl` ä¸­çš„æ‰€æœ‰å†…å®¹éƒ½å°†å’Œ `Rectangle` ç±»å‹ç›¸å…³è”ã€‚

å°† `area` å‡½æ•°çš„å‚æ•° `rectangle: &Rectangle` æ”¹ä¸º `&self`ï¼Œè¿™æœ¬è´¨ä¸Šæ˜¯ `self: &Self` çš„ç¼©å†™ã€‚åœ¨ä¸€ä¸ª `impl` å—ä¸­ï¼Œ`Self` ç±»å‹æ˜¯ `impl` å—çš„ç±»å‹çš„åˆ«åã€‚

- æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æœ‰ä¸€ä¸ªåä¸º `self` çš„ `Self` ç±»å‹çš„å‚æ•°ï¼›
- è¦ä¿®æ”¹è°ƒç”¨æ–¹æ³•çš„å®ä¾‹ï¼Œå¯ä»¥å†™ä¸ºï¼š`&mut self` ä»¥è·å¾—æ‰€æœ‰æƒï¼›

ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†æ–¹æ³•çš„åç§°ä¸ç»“æ„ä¸­çš„ä¸€ä¸ªå­—æ®µç›¸åŒï¼Œä¾‹å¦‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåä¸º `width` çš„æ–¹æ³•ï¼š

```rs
impl Rectangle {
    fn width(&self) -> bool {
        // å½“ self.width > 0 æ—¶è¿”å› true
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```

åœ¨ä½¿ç”¨ `width` æ–¹æ³•æ—¶ï¼Œéœ€è¦ç”¨ `()` æ¥è°ƒç”¨å®ƒã€‚

ä½ ä¹Ÿå¯ä»¥å°† `width` æ–¹æ³•ä»…ä»…è¿”å› `self.width` çš„å€¼ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡è¿™ä¸ª getter è®¿é—®åˆ° `self.width` çš„å€¼ã€‚

ä¸‹é¢æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå¸¦å‚æ•°çš„æ–¹æ³• `can_hold` ç”¨äºæ£€æŸ¥ä¸€ä¸ª `Rectangle` æ˜¯å¦å¯ä»¥åŒ…å«å¦ä¸€ä¸ª `Rectangle`ï¼š

```rs
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn width(&self) -> bool {
        self.width > 0
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rec1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rec2 = Rectangle {
        width: 10,
        height: 40,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rec1.area()
    );
    println!("rec1 can hold rec2: {}", rec1.can_hold(&rec2));
}
```

æˆ‘ä»¬ç»™ `can_hold` ä¼ å…¥äº†ç¬¬äºŒä¸ªå‚æ•° `other`ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Rectangle` å®ä¾‹çš„ä¸å¯å˜å€Ÿç”¨ã€‚

åœ¨è°ƒç”¨ `can_hold` æ—¶ï¼Œç›´æ¥å°† `Rectangle` å®ä¾‹ä¼ å…¥å³å¯ï¼Œè¿™æ—¶æ‰€æœ‰æƒä»ç„¶è¢« `rec2` ä¿æŒï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨è°ƒç”¨å®Œ `can_hold` åç»§ç»­ä½¿ç”¨ `rec2`ã€‚

æ‰€æœ‰åœ¨ `impl` å—ä¸­å®šä¹‰çš„å‡½æ•°è¢«ç§°ä¸º **å…³è”å‡½æ•°**ï¼Œå› ä¸ºå®ƒä»¬ä¸ `impl` åé¢å‘½åçš„ç±»å‹ç›¸å…³ã€‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸ä»¥ `self` ä¸ºç¬¬ä¸€å‚æ•°çš„å…³è”å‡½æ•°ï¼ˆå› æ­¤ä¸æ˜¯æ–¹æ³•ï¼‰ã€‚

å…³è”å‡½æ•°å¹¶ä¸ä½œç”¨äºä¸€ä¸ªå®ä¾‹ï¼Œä¸€ä¸ªæœ€å¥½çš„å…³è”å‡½æ•°ä¾‹å­å°±æ˜¯ `String::from` å‡½æ•°ã€‚

ä¸æ˜¯æ–¹æ³•çš„å…³è”å‡½æ•°ç»å¸¸è¢«ç”¨ä½œè¿”å›ä¸€ä¸ªç»“æ„ä½“æ–°å®ä¾‹çš„æ„é€ å‡½æ•°ï¼ˆåç§°é€šå¸¸ä¸º `new`ï¼Œä½†å®é™…ä¸Š `new` å¹¶ä¸æ˜¯ä¸€ä¸ªå…³é”®å­—ï¼‰ã€‚

ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªåä¸º `square` çš„å…³è”å‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå‚æ•°åŒæ—¶ä½œä¸ºå®½å’Œé«˜ï¼Œé€šè¿‡ `square` å£°æ˜ `Rectangle` æ—¶ä¸å¿…æŒ‡å®šä¸¤æ¬¡åŒæ ·çš„å€¼ï¼š

```rs
impl Rectangle {
    fn square(size: u32) -> Self {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let sq = Rectangle::square(30); // åˆ›å»ºä¸€ä¸ª 30*30 çš„æ­£æ–¹å½¢
}
```

ä½¿ç”¨ç»“æ„ä½“åå’Œ `::` è¯­æ³•æ¥è°ƒç”¨è¿™ä¸ªå…³è”å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä½äºç»“æ„ä½“çš„å‘½åç©ºé—´ä¸­ï¼Œ`::` è¯­æ³•ç”¨äºå…³è”å‡½æ•°å’Œæ¨¡å—åˆ›å»ºçš„å‘½åç©ºé—´ã€‚

æ¯ä¸ªç»“æ„ä½“éƒ½å…è®¸æ‹¥æœ‰å¤šä¸ª `impl` å—ï¼Œä½ å¯ä»¥åœ¨ä¸åŒçš„ `impl` ä¸­å£°æ˜æ–¹æ³•æˆ–å…³è”å‡½æ•°ï¼Œåœ¨åé¢çš„ç« èŠ‚ä¸­ä¼šè§åˆ°å®ç”¨çš„å¤š `impl` å—çš„ç”¨ä¾‹ã€‚

## æšä¸¾å’Œæ¨¡å¼åŒ¹é…

### æšä¸¾çš„å®šä¹‰

åœ¨å‰æ–‡ä¸­æˆ‘ä»¬ä»‹ç»äº†ç»“æ„ä½“ï¼Œå®ƒå¯ä»¥å°†å­—æ®µå’Œæ•°æ®èšåˆåœ¨ä¸€èµ·ï¼š

`Rectangle` ç»“æ„ä½“ä¸­åŒ…å« `width` å’Œ `height` ä¸¤ä¸ªå­—æ®µï¼Œè¿˜å¯ä»¥åŒ…å«æ–¹æ³•ã€‚

è€Œæšä¸¾å¯ä»¥æä¾›ä¸€ç§é€”å¾„ï¼Œç”¨äºå£°æ˜æŸä¸ªå€¼æ˜¯ä¸€ä¸ªé›†åˆä¸­çš„ä¸€å‘˜ï¼š

`Rectangle` æ˜¯ä¸€äº›å½¢çŠ¶çš„é›†åˆï¼Œä¾‹å¦‚ï¼š`Circle` å’Œ `Triangle`ã€‚

ä¸‹é¢çš„ä»£ç å£°æ˜äº†ä¸€ä¸ªæšä¸¾ç±»å‹ `IpAddrKind`ï¼Œå®ƒåŒ…å« `V4` ä¸ `V6` ä¸¤ä¸ªæˆå‘˜ï¼š

```rs
enum IpAddrKind {
    V4,
    V6
}
```

å¯ä»¥ `IpAddrKind` æšä¸¾åˆ›å»ºä¸åŒæˆå‘˜çš„å®ä¾‹ï¼š

```rs
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

æšä¸¾çš„æˆå‘˜ä½äºå…¶æ ‡è¯†ç¬¦çš„å‘½åç©ºé—´ä¸­ï¼Œå¹¶ä½¿ç”¨ä¸¤ä¸ªå†’å·åˆ†å¼€ã€‚

ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œæšä¸¾æˆå‘˜ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `route` å‡½æ•°ï¼Œä¸è®ºç±»å‹æ˜¯ `V4` è¿˜æ˜¯ `V6`ï¼š

```rs
fn route(ip_kind: IpAddrKind) {}

route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„æšä¸¾éƒ½æ˜¯ä»¥**ç±»å‹**å½¢å¼å­˜åœ¨çš„ï¼Œå¹¶æ²¡æœ‰ä¸€ä¸ªå®é™…å­˜å‚¨ IP åœ°å€æ•°æ®çš„åœ°æ–¹ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ª `IpAddr` ç»“æ„ä½“æ¥å®Œæˆè¿™æ ·çš„å·¥ä½œï¼š

```rs
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
}

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
}
```

å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ç§æ›´ä¸ºç®€æ´çš„æ–¹å¼æ¥è¡¨è¾¾ç›¸åŒçš„æ¦‚å¿µï¼š

åªä½¿ç”¨æšä¸¾ï¼Œå¹¶å°†æ•°æ®ç›´æ¥æ”¾è¿›æ¯ä¸ªæšä¸¾æˆå‘˜ä¸­ï¼Œè€Œä¸æ˜¯ç”¨ç»“æ„ä½“ï¼š

```rs
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
```

è¿™æ ·ï¼Œæˆ‘ä»¬å°±ä¸å†éœ€è¦é¢å¤–çš„ç»“æ„ä½“æ¥å®Œæˆï¼šå°†æ•°æ®é™„åŠ åˆ°æšä¸¾æˆå‘˜ä¸Š è¿™ä»¶äº‹äº†ã€‚

å¦å¤–ï¼Œä½ ä¹Ÿä¼šå‘ç°ï¼Œå®šä¹‰æšä¸¾æˆå‘˜çš„åå­—ä¹Ÿå˜æˆäº†ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼š`IpAddr::V4()` è·å–ä¸€ä¸ª `String` ç±»å‹çš„å‚æ•°ï¼Œå¹¶è¿”å› `IpAddr` ç±»å‹å®ä¾‹ã€‚

ç”¨æšä¸¾æ¥æ›¿ä»£ç»“æ„ä½“è¿˜å¸¦æ¥äº†å¦ä¸€ä¸ªä¼˜åŠ¿ï¼šå¯ä»¥ç»™ä¸åŒçš„æšä¸¾å¯¹è±¡ç»‘å®šä¸åŒçš„æ•°æ®ç±»å‹

```rs
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
```

[æ ‡å‡†åº“](https://doc.rust-lang.org/std/net/enum.IpAddr.html)æ˜¯è¿™æ ·å¤„ç†IPåœ°å€çš„ï¼š

```rs
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

å¦ä¸€ä¸ªæšä¸¾çš„ä¾‹å­ `Message`ï¼š

```rs
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

æˆ‘ä»¬å½“ç„¶å¯ä»¥ç”¨ `struct` å¤å†™è¿™æ ·çš„æšä¸¾ï¼š

```rs
struct QuitMessage; // ç±»å•å…ƒç»“æ„ä½“
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // å…ƒç»„ç»“æ„ä½“
struct ChangeColorMessage(i32, i32, i32); // å…ƒç»„ç»“æ„ä½“
```

ç„¶è€Œï¼Œè¿™äº›ç»“æ„ä½“éƒ½æœ‰ä¸åŒçš„ç±»å‹ï¼Œè€Œæšä¸¾çš„ä¸åŒæˆå‘˜æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚

æšä¸¾å’Œç»“æ„ä½“å¦ä¸€ä¸ªç›¸ä¼¼çš„åœ°æ–¹æ˜¯ï¼š

- ç»“æ„ä½“å¯ä»¥ä½¿ç”¨ `impl` æ¥å®šä¹‰æ–¹æ³•
- æšä¸¾å¯ä»¥é€šè¿‡åä¸º `call` çš„æ–¹æ³•æ¥å®šä¹‰

```rs
impl Message {
    fn call(&self) {
        // some code ...
    }
}

let m = Message::Write(String::from("Hello"));
m.call();
```

ä¸‹é¢ä»‹ç»ä¸€ä¸ªæ ‡å‡†åº“ä¸­å¸¸è§ä¸”éå¸¸å®ç”¨çš„æšä¸¾ `Option`ã€‚

`Option` ç±»å‹åº”ç”¨å¹¿æ³›ï¼Œæ˜¯å› ä¸ºå®ƒç¼–ç äº†ä¸€ä¸ªæ™®éçš„åœºæ™¯ï¼šä¸€ä¸ªå€¼è¦ä¹ˆæœ‰å€¼è¦ä¹ˆæ²¡å€¼ã€‚

ä¾‹å¦‚ï¼šè¯·æ±‚ä¸€ä¸ªéç©ºåˆ—è¡¨çš„ç¬¬ä¸€é¡¹ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªå€¼ï¼›è¯·æ±‚ä¸€ä¸ªç©ºçš„åˆ—è¡¨ï¼Œé‚£ä¹ˆå°±ä»€ä¹ˆéƒ½ä¸ä¼šå¾—åˆ°ã€‚

ä»ç±»å‹ç³»ç»Ÿçš„è§’åº¦æ¥è¡¨è¾¾è¿™ä¸ªæ¦‚å¿µï¼Œæ„å‘³ç€ç¼–è¯‘å™¨éœ€è¦æ£€æŸ¥æ˜¯å¦å¤„ç†äº†æ‰€æœ‰åº”è¯¥å¤„ç†çš„æ‰€æœ‰æƒ…å†µã€‚

Rust å¹¶æ²¡æœ‰å…¶ä»–è¯­è¨€ä¸­ç©ºå€¼ï¼ˆ`null`ï¼‰çš„åŠŸèƒ½ï¼Œåœ¨æœ‰ç©ºå€¼çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ€»æ˜¯è¿™ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šç©ºå€¼å’Œéç©ºå€¼ã€‚

åœ¨ Rust ä¸­å­˜åœ¨ä¸€ä¸ªå¯ä»¥ç¼–ç å­˜åœ¨æˆ–ä¸å­˜åœ¨æ¦‚å¿µçš„æšä¸¾ï¼š`Option<T>`ï¼Œè¢«å®šä¹‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œå¹¶ä¸”åŒ…å«åœ¨äº† prelude ä¸­ï¼Œè¿™æ„å‘³ç€ä½ ä¸éœ€è¦æ˜¾å¼å°†å…¶å¼•å…¥ä½œç”¨åŸŸã€‚

```rs
enum Option<T> {
    None,
    Some(T),
}
```

ç”šè‡³ï¼Œä½ ä¸éœ€è¦ `Option::` çš„å‰ç¼€æ¥ä½¿ç”¨ `Some` å’Œ `None`ï¼Œä¸‹é¢æ˜¯ä¸€äº› `Option` çš„ä¾‹å­ï¼š

```rs
let some_number = Some(5);
let some_char = Some('e');
let absent_number: Option<i32> = None;
```

`some_number` å’Œ `some_char` çš„ç±»å‹ç”± Rust è‡ªåŠ¨æ¨æ–­ï¼Œè€Œ `absent_number` åˆ™æ˜¯é€šè¿‡æ³›å‹æŒ‡å®šå‘Šè¯‰ Rust çš„ã€‚

ç¼–è¯‘å™¨ä¸å…è®¸åƒä¸€ä¸ªè‚¯å®šæœ‰æ•ˆçš„å€¼é‚£æ ·ä½¿ç”¨ `Option<T>`ï¼Œå› ä¸ºæœ¬è´¨ä¸Š `Option<T>` ä¸ `T` æ˜¯ä¸åŒçš„ç±»å‹ï¼š

```rs
// æ­¤ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y; // âŒ
```

ç¼–è¯‘å™¨ç¡®ä¿ `i8` ç±»å‹å§‹ç»ˆæœ‰å€¼ï¼Œä¸éœ€è¦åšç©ºå€¼æ£€æŸ¥ã€‚åªæœ‰å½“ä½¿ç”¨å¦‚ `Option<i8>` è¿™æ ·çš„å€¼çš„æ—¶æ‰ä¼šæ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚

æ¢å¥è¯è¯´ï¼Œåœ¨å¯¹ `Option<i8>` è¿›è¡Œè¿ç®—ä¹‹å‰ï¼Œå¿…é¡»å°†å…¶è½¬æ¢ä¸º `T`ï¼Œè¿™èƒ½å¸®åŠ©æˆ‘ä»¬æ•è·åˆ°ç©ºå€¼æœ€å¸¸è§çš„é—®é¢˜ä¹‹ä¸€ï¼šå‡è®¾æŸå€¼ä¸ä¸ºç©ºä½†å®é™…ä¸Šä¸ºç©ºçš„æƒ…å†µã€‚

è¿™æ ·å°±æ¶ˆé™¤äº†é”™è¯¯åœ°å‡è®¾ä¸€ä¸ªéç©ºå€¼çš„é£é™©ï¼šä¸ºäº†æ‹¥æœ‰ä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å€¼ï¼Œä½ å¿…é¡»è¦æ˜¾å¼åœ°å°†å…¶æ”¾å…¥å¯¹åº”ç±»å‹çš„ `Option<T>` ä¸­ï¼Œå½“ä½ è¦ä½¿ç”¨è¿™ä¸ªå€¼çš„æ—¶å€™ï¼Œå¿…é¡»æ˜ç¡®å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µã€‚

åªè¦ä¸€ä¸ªå€¼ä¸æ˜¯ `Option<T>` ç±»å‹ï¼Œä½ å°±**å¯ä»¥**å®‰å…¨ç¬¬è®¤å®šå®ƒçš„å€¼ä¸ä¸ºç©ºã€‚

æ›´å¤šåœ°å…³äº `Option<T>` çš„ç”¨æ³•ï¼Œå¯ä»¥çœ‹[å®ƒçš„æ–‡æ¡£](https://doc.rust-lang.org/std/option/enum.Option.html)ã€‚

å¦‚æœä½ å¸Œæœ›ä¸€äº›ä»£ç ä»…åœ¨æœ‰å€¼ `Some(T)` æ—¶æ‰è¿è¡Œï¼Œå¹¶å…è®¸è¿™äº›ä»£ç ä½¿ç”¨å…¶ä¸­çš„ `T`ï¼Œæˆ–è€…æ˜¯ä½ å¸Œæœ›å½“å€¼ä¸º `None` æ—¶åšä¸€äº›é”™è¯¯å¤„ç†æ—¶ï¼Œå¯ä»¥è¯•è¯•ç”¨ `match`ã€‚

ä¸‹æ–‡ä¸­æˆ‘ä»¬å°†ä»‹ç» `match` æ§åˆ¶æµç»“æ„ï¼Œ`match` è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªå¤„ç†æšä¸¾çš„æ§åˆ¶æµç»“æ„ï¼šå®ƒä¼šæ ¹æ®æšä¸¾çš„æˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç ï¼Œè¿™äº›ä»£ç å¯ä»¥ä½¿ç”¨åŒ¹é…åˆ°å€¼ä¸­çš„æ•°æ®ã€‚

### match æ§åˆ¶æµç»“æ„

Rust æ‹¥æœ‰ä¸€ä¸ªåä¸º `match` çš„æä¸ºå¼ºå¤§çš„æ§åˆ¶æµè¿ç®—ç¬¦ï¼Œå®ƒå…è®¸æˆ‘ä»¬å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œç›¸åº”çš„ä»£ç ã€‚

æ¨¡å¼ï¼ˆpatternï¼‰å¯ä»¥ç”±å­—é¢å€¼ã€å˜é‡ã€é€šé…ç¬¦å’Œè®¸å¤šå…¶ä»–å†…å®¹ç»„æˆï¼Œ`match` çš„åŠ›é‡æ¥æºäºæ¨¡å¼çš„è¡¨ç°åŠ›ä¸ç¼–è¯‘å™¨æ£€æŸ¥ï¼Œå®ƒç¡®ä¿äº†æ‰€æœ‰å¯èƒ½å¾—æƒ…å†µéƒ½èƒ½å¾—åˆ°å¤„ç†ã€‚

æŠŠ `match` è¡¨è¾¾å¼æƒ³è±¡æˆæŸç§ç¡¬å¸åˆ†ç±»å™¨ï¼šç¡¬å¸æ»‘å…¥æœ‰ç€ä¸åŒå¤§å°å­”æ´çš„è½¨é“ï¼Œæ¯ä¸ªç¡¬å¸éƒ½ä¼šè°ƒå…¥ç¬¦åˆå…¶å¤§å°çš„å­”æ´ä¸­ã€‚åŒæ ·åœ°ï¼Œå€¼ä¹Ÿä¼šé€šè¿‡ `match` çš„æ¯ä¸€ä¸ªæ¨¡å¼ï¼Œå¹¶ä¸”åœ¨é‡åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆçš„æ¨¡å¼æ—¶ï¼Œå€¼ä¼šè¿›å…¥ç›¸å…³è”çš„ä»£ç å—ï¼Œå¹¶åœ¨æ‰§è¡Œä¸­è¢«ä½¿ç”¨ã€‚

ä¸€ä¸ªéªŒé’æœºçš„ä¾‹å­ï¼š

```rs
// ç¡¬å¸ => ç¾åˆ†
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

`match` ä¸­çš„åŒ¹é…åˆ†æ”¯ï¼Œå¯ä»¥ç»‘å®šåŒ¹é…çš„æ¨¡å¼çš„éƒ¨åˆ†å€¼ï¼š

```rs
#[derive(Debug)] // è¿™æ ·å¯ä»¥ç«‹åˆ»çœ‹åˆ°å·çš„åç§°
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

è¿™é‡Œæˆ‘ä»¬ç»™ `Coin::Quarter` ä¼ å…¥å·åï¼Œä»¥åŒºåˆ†ä¸åŒå·å¯¹ 25 ç¾åˆ†çš„ç‰¹æ®Šè®¾è®¡ã€‚

åœ¨ `match` è¡¨è¾¾å¼ä¸­ï¼Œä¸€æ—¦åŒ¹é…äº†æ­¤æ¨¡å¼ï¼Œå˜é‡ `state` å˜é‡å°†ä¼šç»‘å®šå¯¹åº”çš„å·å€¼ï¼Œéšåå°±å¯ä»¥åœ¨å½“å‰åŒ¹é…åˆ†æ”¯ä¸­ä½¿ç”¨ `state`ï¼š

```rs
value_in_cents(Coin::Quarter(UsState::Alaska));

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

è¾“å‡ºä¸ºï¼š

```sh
> State quarter from Alaska!
```

ä¸‹é¢æˆ‘ä»¬å°è¯•ç”¨ `match` æ¥åŒ¹é… `Option<T>` çš„å€¼ï¼š

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè·å–ä¸€ä¸ª `Option<i32>`ï¼Œå¦‚æœå…¶æœ‰å€¼ï¼Œåˆ™å°†å€¼ +1ï¼Œå¦‚æœæ²¡æœ‰å€¼ï¼Œåˆ™è¿”å› `None`ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚

```rs
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

ä¼ å…¥ `Some(5)` åï¼Œ`match` è¡¨è¾¾å¼åŒ¹é…åˆ°äº† `Some(i)` è¿™ä¸€æ¨¡å¼ï¼Œè¿›å…¥åˆ†æ”¯ï¼Œåœ¨åˆ†æ”¯ä¸­è·å¾— `T` çš„å€¼ä¹Ÿå°±æ˜¯ `5`ï¼Œå°†å…¶åŠ ä¸€åè¿”å›ä¸€ä¸ª `Some(6)`ã€‚

::: warning
Rust ä¸­çš„åŒ¹é…æ˜¯ç©·å°½çš„ï¼ˆexhaustiveï¼‰

åœ¨ä½¿ç”¨ `match` è¡¨è¾¾å¼æ—¶ï¼Œä½ å¿…é¡»ä¸ºå€¼çš„æ¯ä¸€ç§æ¨¡å¼éƒ½ç¼–å†™ä¸€ä¸ªåˆ†æ”¯ï¼š

```rs
// æ­¤ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

ç”±äºç¼ºå°‘äº†å¯¹ `None` æƒ…å†µçš„å¤„ç†ï¼Œç¼–è¯‘ä¼šæŠ¥é”™ï¼š

```sh
> error[E0004]: non-exhaustive patterns: `None` not covered
```

å®é™…ä¸Šè¿™ä¹Ÿä½¿æˆ‘ä»¬å…äºå‡è®¾æ‹¥æœ‰ä¸€ä¸ªå®é™…ä¸Šä¸ºç©ºçš„å€¼ã€‚
:::

å¯ä»¥ä½¿ç”¨ `_` ä½œä¸ºå ä½ç¬¦ï¼Œä½œä¸ºå…œåº•æ¨¡å¼ï¼ŒåŒ¹é…æ‰€æœ‰æœªè¢«å…¶ä¹‹å‰åŒ¹é…åˆ°çš„å€¼ï¼š

```rs
let dice_roll = 9;
match dice_roll {
    3 => do_something(),
    7 => do_something_else(),
    _ => reroll() // ğŸ¥³ åŒ¹é…æ‰€æœ‰å‰©ä½™çš„æƒ…å†µ
}

fn do_something() {}
fn do_something_else() {}
fn reroll() {}
```

åŒæ—¶ï¼Œè¿™ä¸ªä¾‹å­æ»¡è¶³å‰æ–‡ä¸­ Rust çš„ç©·ä¸¾æ€§è¦æ±‚ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨æœ€åä¸€ä¸ªåˆ†æ”¯ä¸­æ˜ç¡®å¿½ç•¥äº†å…¶ä»–å€¼ï¼Œè€Œæ²¡æœ‰å¿½ç•¥ä»»ä½•å€¼ã€‚

å¯ä»¥ç”¨å•å…ƒå€¼æ›¿æ¢ç©ºæ“ä½œï¼š

```rs
match dice_roll {
    3 => do_something(),
    7 => do_something_else(),
    _ => () // å•å…ƒå€¼ï¼ˆæœ¬è´¨æ˜¯ç©ºå…ƒç»„ï¼‰
}
```

è¿™æ ·åœ¨æœªåŒ¹é… 3 æˆ– 7 æ—¶å°†ä¸ä¼šåšä»»ä½•äº‹æƒ…ã€‚

### if let ç®€æ´æ§åˆ¶æµ

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªå…³å¿ƒ `match` è¡¨è¾¾å¼ä¸­æŸä¸€ç§æƒ…å†µåæ‰§è¡Œçš„æ•ˆæœï¼Œè¿™æ—¶å¯ä»¥ä½¿ç”¨ `if let` è¯­æ³•æ¥ç®€åŒ–åŸæœ¬å†—ä½™çš„ `match`ï¼š

```rs
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max);
}
```

ä½¿ç”¨ `if let` è¯­æ³•ç®€åŒ–åçš„ä»£ç ï¼š

```rs
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
```

`if let` è¯­æ³•é€šè¿‡ç­‰å·åˆ†éš”çš„ä¸€ä¸ªæ¨¡å¼å’Œä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„å·¥ä½œæ–¹æ³•ä¸ `match` ç›¸åŒï¼š

- `Some(max)` æ˜¯ä¸€ä¸ªæ¨¡å¼ï¼Œ`max` ç»‘å®šä¸º `Some` ä¸­çš„å€¼ï¼›
- æ¨¡å¼è¢«åŒ¹é…æ—¶ï¼Œåˆ†æ”¯è¢«æ‰§è¡Œï¼Œå¯ä»¥åœ¨ `if let` ä»£ç å—ä¸­ä½¿ç”¨ `max`ã€‚

æ¢å¥è¯è¯´ï¼Œå¯ä»¥è®¤ä¸º `if let` æ˜¯ `match` çš„è¯­æ³•ç³–ï¼Œå½“å®ƒçš„å€¼åŒ¹é…æ—¶æ‰§è¡Œä»£ç è€Œå¿½ç•¥æ‰€æœ‰å…¶ä»–å€¼ã€‚

å¯ä»¥åœ¨ `if let` ä¸­åŒ…å«ä¸€ä¸ª `else`ã€‚`else` å—ä¸­çš„ä»£ç ä¸ `match` è¡¨è¾¾å¼ä¸­çš„ `_` åˆ†æ”¯å—ä¸­çš„ä»£ç ç›¸åŒã€‚

æˆ‘ä»¬ç”¨å…ˆå‰çš„ `match` ä¾‹å­æ”¹å†™ï¼Œä½¿ç”¨ `if let` ä¸ `else` æ¥å®ç°ï¼š

```rs
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

## ä½¿ç”¨åŒ…ã€Crate å’Œæ¨¡å—ç®¡ç†ä¸æ–­å¢é•¿çš„é¡¹ç›®

ç¼–å†™å¤§å‹é¡¹ç›®ä¸­ï¼Œä¸€èˆ¬ä¼šå°†ä»£ç åˆ†è§£ä¸ºå¤šä¸ªæ¨¡å—ç›’å¤šä¸ªæ–‡ä»¶æ¥ç»„ç»‡ã€‚

ä¸€ä¸ªåŒ…å¯ä»¥åŒ…å«å¤šä¸ªäºŒè¿›åˆ¶ crate é¡¹å’Œä¸€ä¸ªå¯é€‰çš„ crate åº“ï¼Œä¼´éšç€åŒ…çš„å¢é•¿ï¼Œä½ å¯ä»¥å°†åŒ…ä¸­çš„éƒ¨åˆ†ä»£ç æå–å‡ºæ¥ï¼Œåšæˆç‹¬ç«‹çš„ crateï¼Œå°†è¿™äº› crate ä½œä¸ºå¤–éƒ¨ä¾èµ–é¡¹ã€‚

- åŒ…ï¼ˆPackageï¼‰ï¼šCargo çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œå®ƒå…è®¸ä½ æ„å»ºã€æµ‹è¯•å’Œåˆ†äº« crateã€‚
- **Crates**ï¼šä¸€ä¸ªæ¨¡å—çš„æ ‘å½¢ç»“æ„ï¼Œå®ƒå½¢æˆäº†åº“æˆ–äºŒè¿›åˆ¶é¡¹ç›®ã€‚
- **æ¨¡å—**ï¼ˆModuleï¼‰å’Œ **use**ï¼šå…è®¸ä½ æ§åˆ¶ä½œç”¨åŸŸå’Œè·¯å¾„çš„ç§æœ‰æ€§ã€‚
- **è·¯å¾„**ï¼ˆpathï¼‰ï¼šä¸€ä¸ªå‘½åä¾‹å¦‚ç»“æ„ä½“ã€å‡½æ•°æˆ–æ¨¡å—ç­‰é¡¹çš„æ–¹å¼

### åŒ…å’Œ Crate

crate æ˜¯ Rust åœ¨ç¼–è¯‘æ—¶çš„æœ€å°çš„ä»£ç å•ä½ã€‚å¦‚æœä½ ç”¨ `rustc` è€Œä¸æ˜¯ `cargo` æ¥ç¼–è¯‘ä¸€ä¸ªæ–‡ä»¶ï¼Œç¼–è¯‘å™¨è¿˜æ˜¯ä¼šå°†é‚£ä¸ªæ–‡ä»¶è®¤ä½œä¸€ä¸ª crateã€‚

crate å¯ä»¥åŒ…å«æ¨¡å—ï¼Œæ¨¡å—å¯ä»¥å®šä¹‰åœ¨å…¶ä»–æ–‡ä»¶ï¼Œç„¶åå’Œ crate ä¸€èµ·ç¼–è¯‘ã€‚

crate æœ‰ä¸¤ç§å½¢å¼ï¼šäºŒè¿›åˆ¶å’Œåº“ï¼š

- äºŒè¿›åˆ¶é¡¹å¯ä»¥è¢«ç¼–è¯‘ä¸ºå¯æ‰§è¡Œç¨‹åºï¼Œæ¯”å¦‚ä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åºæˆ–è€…ä¸€ä¸ªæœåŠ¡å™¨ã€‚
  - å®ƒå¿…é¡»æœ‰ä¸€ä¸ª `main` å‡½æ•°æ¥å®šä¹‰å½“ç¨‹åºè¢«æ‰§è¡Œæ—¶çš„æ—¶å€™æ‰€éœ€è¦åšçš„äº‹æƒ…ã€‚
- åº“ å¹¶æ²¡æœ‰ `main` å‡½æ•°ï¼Œå®ƒä»¬ä¹Ÿä¸ä¼šè¢«ç¼–è¯‘ä¸ºå¯æ‰§è¡Œç¨‹åºï¼Œå®ƒä»¬æä¾›ä¸€äº›è¯¸å¦‚å‡½æ•°ä¹‹ç±»çš„ä¸œè¥¿ï¼Œä½¿å…¶ä»–é¡¹ç›®ä¹Ÿèƒ½ä½¿ç”¨è¿™äº›ä¸œè¥¿ã€‚

crate root æ˜¯ä¸€ä¸ªæºæ–‡ä»¶ï¼ŒRust ç¼–è¯‘å™¨ä»¥å®ƒä¸ºèµ·ç‚¹ï¼Œå¹¶æ„æˆä½ çš„ crate æ ¹æ¨¡å—ã€‚

åŒ…ï¼ˆPackageï¼‰æ˜¯æä¾›ä¸€ç³»åˆ—åŠŸèƒ½çš„ä¸€ä¸ªæˆ–å¤šä¸ª crateã€‚ä¸€ä¸ªåŒ…ä¼šåŒ…å«ä¸€ä¸ª Cargo.toml æ–‡ä»¶ï¼Œé˜è¿°å¦‚ä½•å»æ„å»ºè¿™äº› crateã€‚Cargo å°±æ˜¯ä¸€ä¸ªåŒ…å«æ„å»ºä½ ä»£ç çš„äºŒè¿›åˆ¶é¡¹çš„åŒ…ã€‚Cargo ä¹ŸåŒ…å«è¿™äº›äºŒè¿›åˆ¶é¡¹æ‰€ä¾èµ–çš„åº“ã€‚å…¶ä»–é¡¹ç›®ä¹Ÿèƒ½ç”¨ Cargo åº“æ¥å®ç°ä¸ Cargo å‘½ä»¤è¡Œç¨‹åºä¸€æ ·çš„é€»è¾‘ã€‚

åŒ…ä¸­å¯ä»¥åŒ…å«è‡³å¤šä¸€ä¸ªåº“ crateï¼ˆlibrary crateï¼‰ã€‚åŒ…ä¸­å¯ä»¥åŒ…å«ä»»æ„å¤šä¸ªäºŒè¿›åˆ¶ crateï¼ˆbinary crateï¼‰ï¼Œä½†æ˜¯å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª crateï¼ˆæ— è®ºæ˜¯åº“è¿˜æ˜¯äºŒè¿›åˆ¶çš„ï¼‰ï¼›

```sh
cargo new my-project
```

### å®šä¹‰æ¨¡å—æ¥æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§

ä¸‹é¢è§£é‡Šä¸€ä¸‹æ¨¡å—ã€è·¯å¾„ã€`use` å…³é”®è¯å’Œ `pub` å…³é”®è¯å¦‚ä½•åœ¨ç¼–è¯‘å™¨ä¸­å·¥ä½œï¼š

- ä» crate æ ¹èŠ‚ç‚¹å¼€å§‹
  - å½“ç¼–è¯‘ä¸€ä¸ª crateï¼Œç¼–è¯‘å™¨é¦–å…ˆåœ¨ crate æ ¹æ–‡ä»¶ï¼ˆåº“ crate é€šå¸¸æ˜¯ *src/lib.rs*ï¼ŒäºŒè¿›åˆ¶ crate é€šå¸¸æ˜¯ *src/main.rs*ï¼‰
- å£°æ˜æ¨¡å—
  - åœ¨ crate æ ¹æ–‡ä»¶ä¸­ï¼Œä½ å¯ä»¥å£°æ˜ä¸€ä¸ªæ–°æ¨¡å—ï¼Œä¾‹å¦‚ï¼š`mod garden;` å£°æ˜äº†ä¸€ä¸ªåä¸º `garden` çš„æ¨¡å—ã€‚ç¼–è¯‘å™¨ä¼šåœ¨ä¸‹åˆ—è·¯å¾„ä¸­å¯»æ‰¾æ¨¡å—ä»£ç ï¼š
    - å†…è”ï¼Œåœ¨å¤§æ‹¬å·ä¸­ï¼Œå½“ `mod garden` åæ–¹ä¸æ˜¯ä¸€ä¸ªåˆ†å·è€Œæ˜¯ä¸€ä¸ªå¤§æ‹¬å·ï¼ˆ`mod garden {}`ï¼‰
    - åœ¨æ–‡ä»¶ *src/garden.rs*
    - åœ¨æ–‡ä»¶ *src/garden/mod.rs*
- å£°æ˜å­æ¨¡å—
  - åœ¨é™¤äº† crate æ ¹èŠ‚ç‚¹ä»¥å¤–çš„å…¶ä»–æ–‡ä»¶ä¸­ï¼Œä½ å¯ä»¥å®šä¹‰å­æ¨¡å—ï¼Œä¾‹å¦‚ä½ å¯èƒ½åœ¨ *src/garden.rs* ä¸­å®šä¹‰äº† `mod vegetables;`ã€‚ç¼–è¯‘å™¨ä¼šåœ¨çˆ¶æ¨¡å—å‘½åçš„ç›®å½•ä¸­ç»§ç»­å¯»æ‰¾å­æ¨¡å—ä»£ç ï¼š
    - å†…è”ï¼Œåœ¨å¤§æ‹¬å·ä¸­ï¼Œå½“ `mod vegetables` åæ–¹ä¸æ˜¯ä¸€ä¸ªåˆ†å·è€Œæ˜¯ä¸€ä¸ªå¤§æ‹¬å·
    - åœ¨æ–‡ä»¶ *src/garden/vegetables.rs*
    - åœ¨æ–‡ä»¶ *src/garden/vegetables/mod.rs*
- æ¨¡å—ä¸­çš„ä»£ç è·¯å¾„
  - ä¸€æ—¦ä¸€ä¸ªæ¨¡å—æ˜¯ä½  crate çš„ä¸€éƒ¨åˆ†ï¼Œä½ å¯ä»¥åœ¨éšç§è§„åˆ™å…è®¸çš„å‰æä¸‹ï¼Œä»åŒä¸€ä¸ª crate å†…çš„ä»»æ„åœ°æ–¹ï¼Œé€šè¿‡ä»£ç è·¯å¾„å¼•ç”¨è¯¥æ¨¡å—çš„ä»£ç ã€‚
  - ä¾‹å¦‚ï¼šä¸€ä¸ª garden vegetables æ¨¡å—ä¸‹çš„ `Asparagus` ç±»å‹å¯ä»¥åœ¨ `crate::garden::vegetables::Asparagus` è¢«æ‰¾åˆ°ã€‚
- ç§æœ‰ vs å…¬ç”¨
  - ä¸€ä¸ªæ¨¡å—é‡Œçš„ä»£ç é»˜è®¤å¯¹å…¶çˆ¶æ¨¡å—ç§æœ‰ã€‚ä¸ºäº†è®©ä¸€ä¸ªæ¨¡å—å…¬ç”¨ï¼Œåº”å½“åœ¨å£°æ˜æ—¶ä½¿ç”¨ `pub mod` ä»£æ›¿ `mod`ã€‚ä¸ºäº†ä½¿ä¸€ä¸ªå…¬ç”¨æ¨¡å—çš„å†…éƒ¨æˆå‘˜å…¬ç”¨ï¼Œåº”å½“åœ¨å£°æ˜å‰ä½¿ç”¨ `pub`ã€‚
- `use` å…³é”®å­—
  - åœ¨ä¸€ä¸ªä½œç”¨åŸŸå†…ï¼Œ`use` å…³é”®å­—åˆ›å»ºäº†ä¸€ä¸ªæˆå‘˜çš„å¿«æ·æ–¹å¼ï¼Œç”¨æ¥å‡å°‘é•¿è·¯å¾„çš„é‡å¤ã€‚
  - åœ¨ä»»ä½•å¯ä»¥å¼•ç”¨ `crate::garden::vegetables::Asparagus` çš„ä½œç”¨åŸŸï¼Œä½ å¯ä»¥é€šè¿‡ `use crate::garden::vegetables::Asparagus;` åˆ›å»ºä¸€ä¸ªå¿«æ·æ–¹å¼ï¼Œéšåä½ åœ¨ä½œç”¨åŸŸä¸­å°±å¯ä»¥ç›´æ¥ä½¿ç”¨ `Asparagus` æ¥ä½¿ç”¨è¯¥ç±»å‹ã€‚

::: code-group
```rs [main.rs]
// src/main.rs
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}

```

```rs [garden.rs]
// src/garden.rs
pub mod vegetables;
```

```rs [vegetables.rs]
// src/garden/vegetables.rs
#[derive(Debug)]
pub struct Asparagus {}
```
:::

åœ¨æ¨¡å—ä¸­å¯¹ç›¸å…³ä»£ç è¿›è¡Œåˆ†ç»„

æ¨¡å—å¯ä»¥è®©æˆ‘ä»¬å°†ä¸€ä¸ª crate ä¸­çš„ä»£ç è¿›è¡Œåˆ†ç»„ï¼Œä»¥æé«˜å¯è¯»æ€§å’Œå¯é‡ç”¨æ€§ã€‚å› ä¸ºç¬¬ä¸€ä¸ªæ¨¡å—ä¸­çš„ä»£ç é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œæ‰€ä»¥è¿˜å¯ä»¥åˆ©ç”¨æ¨¡å—æ§åˆ¶é¡¹çš„ç§æœ‰æ€§ã€‚

```rs
// src/lib.rs
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

æ¨¡å—å®šä¹‰ä»¥ `mod` å¼€å§‹ï¼Œç„¶åæŒ‡å®šæ¨¡å—çš„åå­—ï¼š`front_of_house`ã€‚

åœ¨æ¨¡å—å†…ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å®šä¹‰å…¶ä»–çš„æ¨¡å—ï¼š`hosting` å’Œ `serving` æ¨¡å—ã€‚

æ¨¡å—ä¸­è¿˜å¯ä»¥ä¿å­˜ä¸€äº›å®šä¹‰çš„å…¶ä»–é¡¹ï¼Œå¦‚ç»“æ„ä½“ã€æšä¸¾ã€å¸¸é‡ã€ç‰¹æ€§ã€å‡½æ•°ã€‚

è¿™æ ·çš„ç»“æ„ç»„æˆäº†ä¸€ä¸ªæ¨¡å—æ ‘ï¼š

- crate
  - front_of_house
    - hosting
      - add_to_waitlist
      - seat_at_table
    - serving
      - take_order
      - serve_order
      - take_payment

Rust åœ¨æ¨¡å—æ ‘ä¸­æ‰¾åˆ°ä¸€ä¸ªé¡¹çš„ä½ç½®ï¼Œéœ€è¦çŸ¥é“å¼•ç”¨æ¨¡å—çš„è·¯å¾„ï¼š

- ç»å¯¹è·¯å¾„
  - ä»¥ crate æ ¹å¼€å¤´çš„å…¨è·¯å¾„ï¼›
  - å¯¹äºå¤–éƒ¨ crate çš„ä»£ç ï¼Œæ˜¯ä»¥ crate åå¼€å¤´çš„ç»å¯¹è·¯å¾„
  - å¯¹äºå½“å‰ crate çš„ä»£ç ï¼Œåˆ™ä»¥ `crate` å¼€å¤´
- ç›¸å¯¹è·¯å¾„
  - ä»å½“å‰æ¨¡å—å¼€å§‹ï¼Œä»¥ `self`ã€`super` æˆ–å®šä¹‰åœ¨å½“å‰æ¨¡å—ä¸­çš„æ ‡è¯†ç¬¦å¼€å¤´

ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„éƒ½åè·Ÿä¸€ä¸ªæˆ–å¤šä¸ªç”±åŒå†’å·ï¼ˆ`::`ï¼‰åˆ†å‰²çš„æ ‡è¯†ç¬¦ï¼š

ä»¥ä¹‹å‰çš„ä¾‹å­ä¸ºä¾‹ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨æ¨¡å—ä¸­è°ƒç”¨ `add_to_waitlist` å‡½æ•°ï¼š

```rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // ç»å¯¹è·¯å¾„
    crate::front_of_house::hosting::add_to_waitlist();

    // ç›¸å¯¹è·¯å¾„
    front_of_house::hosting::add_to_waitlist();
}
```

ä»£ç ä¸­ä½¿ç”¨ `pub` å…³é”®å­—å£°æ˜ `hosting` æ¨¡å—æ˜¯ä¸€ä¸ªå…¬å…±æ¨¡å—ã€æ¨¡å—å†…çš„ `add_to_waitlist` å‡½æ•°æ˜¯ä¸€ä¸ªå…¬å…±å‡½æ•°ã€‚çˆ¶æ¨¡å—å¯ä»¥è®¿é—®åˆ°å…¬å…±å­æ¨¡å—ä¸­çš„å…¬å…± `add_to_waitlist` å‡½æ•°ã€‚




